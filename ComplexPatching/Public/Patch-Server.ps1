function Patch-Server {
    param
    (
        [parameter(Mandatory = $true)]
        [string]$ComputerName,
        # Provides the computer name to install pathces on

        [parameter(Mandatory = $true)]
        [string]$DryRun,
        # skips patching check so that we can perform a dry run of the drain an resume

        [parameter(Mandatory = $true)]
        [int32]$RBInstance,
        # RBInstance which represents the Runbook Process ID for this runbook workflow

        [parameter(Mandatory = $true)]
        [string]$SQLServer,
        # Database server for staging information during the patching process

        [parameter(Mandatory = $true)]
        [string]$OrchStagingDB,
        # Database for staging information during the patching process

        [parameter(Mandatory = $true)]
        [string]$LogLocation
        # UNC path to store log files in
    )

    #region import modules
    Import-Module -Name ComplexPatching
    #endregion import modules

    #-----------------------------------------------------------------------

    ## Initialize result and trace variables
    # $ResultStatus provides basic success/failed indicator
    # $ErrorMessage captures any error text generated by script
    # $Trace is used to record a running log of actions
    [bool]$DryRun = ConvertTo-Boolean $DryRun
    $ResultStatus = ""
    $ErrorMessage = ""
    $global:CurrentAction = ""
    $Finished = $false
    $ScriptName = $((Split-Path $PSCommandPath -Leaf) -Replace '.ps1', $null)


    #region set our defaults for our functions
    #region Start-CompPatchQuery defaults
    $PSDefaultParameterValues.Add("Start-CompPatchQuery:SQLServer", $SQLServer)
    $PSDefaultParameterValues.Add("Start-CompPatchQuery:Database", $OrchStagingDB)
    #endregion Start-CompPatchQuery defaults

    #region create credential objects
    $RemotingCreds = Get-StoredCredential -ComputerName $ComputerName -SQLServer $SQLServer -Database $OrchStagingDB
    #endregion create credential objects

    #region Write-CMLogEntry defaults
    $Bias = Get-WmiObject -Class Win32_TimeZone | Select-Object -ExpandProperty Bias
    $PSDefaultParameterValues.Add("Write-CMLogEntry:Bias", $Bias)
    $PSDefaultParameterValues.Add("Write-CMLogEntry:FileName", [string]::Format("{0}-{1}.log", $RBInstance, $ComputerName))
    $PSDefaultParameterValues.Add("Write-CMLogEntry:Folder", $LogLocation)
    $PSDefaultParameterValues.Add("Write-CMLogEntry:Component", "[$ComputerName]::[$ScriptName]")
    #endregion Write-CMLogEntry defaults

    #region Get-PendingSCMReboot defaults
    $PSDefaultParameterValues.Add("Get-PendingSCCMReboot:Credential", $RemotingCreds)
    #endregion Get-PendingSCMReboot defaults

    #region Start-CMClientAction defaults
    $PSDefaultParameterValues.Add("Start-CMClientAction:Credential", $RemotingCreds)
    $PSDefaultParameterValues.Add("Start-CMClientAction:SQLServer", $SQLServer)
    $PSDefaultParameterValues.Add("Start-CMClientAction:Database", $OrchStagingDB)
    $PSDefaultParameterValues.Add("Start-CMClientAction:FileName", [string]::Format("{0}-{1}.log", $RBInstance, $ComputerName))
    $PSDefaultParameterValues.Add("Start-CMClientAction:Folder", $LogLocation)
    $PSDefaultParameterValues.Add("Start-CMClientAction:Component", "[$ComputerName]::[$ScriptName]")
    #endregion Start-CMClientAction defaults

    #region Get-UpdateFromDB defaults
    $PSDefaultParameterValues.Add("Get-UpdateFromDB:ComputerName", $ComputerName)
    $PSDefaultParameterValues.Add("Get-UpdateFromDB:RBInstance", $RBInstance)
    $PSDefaultParameterValues.Add("Get-UpdateFromDB:SQLServer", $SQLServer)
    $PSDefaultParameterValues.Add("Get-UpdateFromDB:Database", $OrchStagingDB)
    $PSDefaultParameterValues.Add("Get-UpdateFromDB:FileName", [string]::Format("{0}-{1}.log", $RBInstance, $ComputerName))
    $PSDefaultParameterValues.Add("Get-UpdateFromDB:Folder", $LogLocation)
    $PSDefaultParameterValues.Add("Get-UpdateFromDB:Component", "[$ComputerName]::[$ScriptName]")
    #endregion Get-UpdateFromDB defaults

    #region Set-UpdateInDB defaults
    $PSDefaultParameterValues.Add("Set-UpdateInDB:ComputerName", $ComputerName)
    $PSDefaultParameterValues.Add("Set-UpdateInDB:RBInstance", $RBInstance)
    $PSDefaultParameterValues.Add("Set-UpdateInDB:SQLServer", $SQLServer)
    $PSDefaultParameterValues.Add("Set-UpdateInDB:Database", $OrchStagingDB)
    $PSDefaultParameterValues.Add("Set-UpdateInDB:FileName", [string]::Format("{0}-{1}.log", $RBInstance, $ComputerName))
    $PSDefaultParameterValues.Add("Set-UpdateInDB:Folder", $LogLocation)
    $PSDefaultParameterValues.Add("Set-UpdateInDB:Component", "[$ComputerName]::[$ScriptName]")
    #endregion Set-UpdateInDB defaults

    #region Update-DBServerStatus defaults
    $PSDefaultParameterValues.Add("Update-DBServerStatus:ComputerName", $ComputerName)
    $PSDefaultParameterValues.Add("Update-DBServerStatus:RBInstance", $RBInstance)
    $PSDefaultParameterValues.Add("Update-DBServerStatus:SQLServer", $SQLServer)
    $PSDefaultParameterValues.Add("Update-DBServerStatus:Database", $OrchStagingDB)
    #endregion Update-DBServerStatus defaults
    #endregion set our defaults for our functions

    Write-CMLogEntry "Runbook activity script started - [Running On = $env:ComputerName]"
    Update-DBServerStatus -Status "Started $ScriptName"
    Update-DBServerStatus -Stage 'Start' -Component $ScriptName -DryRun $DryRun

    try {
        $FQDN = Get-FQDNFromDB -ComputerName $ComputerName -SQLServer $SQLServer -Database $OrchStagingDB -

        $CheckPatchQuery = [string]::Format("SELECT [Patch] FROM [dbo].[ServerStatus] WHERE [ServerName] = '{0}'", $ComputerName)
        $Patch = Start-CompPatchQuery -Query $CheckPatchQuery | Select-Object -ExpandProperty Patch
        if ($Patch -and -not $DryRun) {
            #region initiate CIMSession, looping until one is made, or it has been 10 minutes
            Update-DBServerStatus -LastStatus 'Creating CIMSession'
            Write-CMLogEntry 'Creating CIMSession'    
            $newLoopActionSplat = @{
                LoopTimeoutType = 'Minutes'
                ExitCondition   = { $script:CIMSession }
                IfTimeoutScript = {
                    Write-CMLogEntry 'Failed to create CIMSession'
                    throw 'Failed to create CIMsession'
                }
                ScriptBlock     = {
                    $script:CIMSession = New-MrCimSession -Credential $script:RemotingCreds -ComputerName $script:FQDN
                }
                LoopDelay       = 10
                IfSucceedScript = { 
                    Update-DBServerStatus -LastStatus "CIMSession Created"
                    Write-CMLogEntry 'CIMSession created succesfully' 
                }
                LoopTimeout     = 10
            }
            New-LoopAction @newLoopActionSplat
            #endregion initiate CIMSession, looping until one is made, or it has been 10 minutes
            Update-DBServerStatus -LastStatus 'Patching Started' 
            Write-CMLogEntry "Set [Server=$ComputerName] [LastStatus=Patching Started] in DB"

            #region Check for updates and insert into SQL appropriately
            Write-CMLogEntry "Checking CCM_SoftwareUpdate for missing updates that are with a filter `"NOT Name LIKE '%Definition%' and ComplianceState=0`""
            [System.Management.ManagementObject[]]$MissingUpdates = Get-WmiObject -Class CCM_SoftwareUpdate -Filter "NOT Name LIKE '%Definition%' and ComplianceState=0" -Namespace root\CCM\ClientSDK -ComputerName $FQDN -Credential $RemotingCreds -ErrorAction Stop
            if ($MissingUpdates -is [Object]) {
                $PatchCount = $MissingUpdates.Count
                Write-CMLogEntry "Found $PatchCount for $ComputerName"
                Foreach ($Update in $MissingUpdates) {
                    if (($Update.ComplianceState -match "^0$|^2$") -and ($Update.EvaluationState -match "^0$|^1$|^13$")) {
                        if (Get-UpdateFromDB -ArticleID $Update.ArticleID) {
                            Set-UpdateInDB -Action Update -ArticleID $Update.ArticleID -ComplianceState $Update.ComplianceState -EvaluationState $Update.EvaluationState
                        }
                        else {
                            $AssignmentID = Get-CimInstance -CimSession $CIMSession -Classname CCM_TargetedUpdateEx1 -Namespace Root\ccm\softwareupdates\deploymentagent -Filter "UpdateId = '$($Update.UpdateID)'" | Select-Object -ExpandProperty RefAssignments -Unique
                            Set-UpdateInDB -Action Insert -ArticleID $Update.ArticleID -ComplianceState $Update.ComplianceState -EvaluationState $Update.EvaluationState -AssignmentID $AssignmentID
                        }
                    }
                }
            }
            #endregion Check for updates and insert into SQL appropriately

            #region iterate through missing updates, install as needed and note compliance in DB
            if ($MissingUpdates.Count -gt 0) {
                $TotalTimeout = $MissingUpdates.MaxExecutionTime | Measure-Object -Sum | Select-Object -ExpandProperty Sum
                Write-CMLogEntry "Calculated the timeout for all patches to be $($TotalTimeout/60) minutes"
                $Sleep = Get-Random -Minimum 1 -Maximum 30
                Write-CMLogEntry "Sleeping for a random interval of $Sleep seconds"
                Start-Sleep -Seconds $Sleep
                Write-CMLogEntry "Invoking all updates with WMI Method 'InstallUpdates' from 'CCM_SoftwareUpdatesManager'"
                $Invoke = Invoke-WmiMethod -computername $FQDN -Class CCM_SoftwareUpdatesManager -Name InstallUpdates -ArgumentList ( , $MissingUpdates) -Namespace root\ccm\clientsdk -Credential $RemotingCreds -ErrorAction Stop
                if ($Invoke.ReturnValue -eq 0) {
                    Update-DBServerStatus -LastStatus 'Installing Patches'
                    foreach ($Update in $MissingUpdates) {
                        if (Get-UpdateFromDB -ArticleID $Update.ArticleID) {
                            Set-UpdateInDB -Action Update -ArticleID $Update.ArticleID -LastAction 'Update Invoked'
                        }
                        else {
                            $AssignmentID = Get-CimInstance -CimSession $CIMSession -Classname CCM_TargetedUpdateEx1 -Namespace Root\ccm\softwareupdates\deploymentagent -Filter "UpdateId = '$($Update.UpdateID)'" | Select-Object -ExpandProperty RefAssignments -Unique
                            Set-UpdateInDB -Action Insert -ArticleID $Update.ArticleID -ComplianceState $Update.ComplianceState -EvaluationState $Update.EvaluationState -AssignmentID $AssignmentID
                        }
                    }
                }
                else {
                    foreach ($Update in $MissingUpdates) {
                        Set-UpdateInDB -Action Update -ArticleID $Update.ArticleID -ComplianceState '4' -LastAction 'Failed to Invoke'
                    }
                    throw "Failed to invoke updates"
                }

                Start-Sleep -Seconds 30
                $script:Disappeared = $false

                $newLoopActionSplat = @{
                    ScriptBlock     = {
                        Remove-Variable -Name CurrentStatus -ErrorAction SilentlyContinue
                        $CurrentStatus = Get-CimInstance -CimSession $script:CIMSession -Classname CCM_SoftwareUpdate -Namespace root\CCM\ClientSDK -Filter "NOT Name LIKE '%Definition%'" -ErrorAction Stop
                        foreach ($Update in $CurrentStatus) {
                            $ArticleID = $Update.ArticleID
                            $EvaluationState = $Update.EvaluationState
                            switch -regex ($EvaluationState) {
                                "^8$|^9$|^10$|^11$|^12$|^14$|^15$|^16$|^17$|^18$|^19$|^20$|^21$|^22$|^23$" {
                                    $ComplianceState = "1"
                                }
                                '^13$' {
                                    $ComplianceState = "2"
                                }
                                default {
                                    $ComplianceState = "0"
                                }
                            }
                            if (Get-UpdateFromDB -ArticleID $Update.ArticleID) {
                                Set-UpdateInDB -Action Update -ArticleID $ArticleID -ComplianceState $ComplianceState -EvaluationState $EvaluationState
                            }
                            else {
                                $AssignmentID = Get-CimInstance -CimSession $CIMSession -Classname CCM_TargetedUpdateEx1 -Namespace Root\ccm\softwareupdates\deploymentagent -Filter "UpdateId = '$($Update.UpdateID)'" | Select-Object -ExpandProperty RefAssignments -Unique
                                Set-UpdateInDB -Action Insert -ArticleID $ArticleID -ComplianceState $ComplianceState -EvaluationState $EvaluationState -AssignmentID $AssignmentID
                            }
                        }
                        $NotWant = @('1', '2', '3', '4', '5', '6', '7', '11')
                        if ($null -ne ($CurrentStatus.EvaluationState | Select-Object -Unique)) {
                            $Comparison = Compare-Object -ReferenceObject $NotWant -DifferenceObject ($CurrentStatus.EvaluationState | Select-Object -Unique) -IncludeEqual
                            if ($Comparison -and $Comparison.SideIndicator -notcontains '==') {
                                $script:MoveOn = $true
                            }
                            else {
                                $script:MoveOn = $false
                            }
                        }
                        else {
                            $script:Disappeared = $true
                            $script:MoveOn = $true
                        }
                    }
                    LoopTimeoutType = 'Seconds'
                    LoopTimeout     = $TotalTimeout
                    LoopDelay       = 15
                    ExitCondition   = { $script:MoveOn }
                }
                New-LoopAction @newLoopActionSplat
            }

            if ($script:Disappeared) {
                #region Force a couple of update checks and wait 2 minutes
                Write-CMLogEntry "Identified that all updates disappeared from WMI. Will force update checks and recheck for new updates"
                Start-CMClientAction -Schedule UpdateScan, UpdateEval -ComputerName $FQDN
                Start-Sleep -Seconds 120
                Start-CMClientAction -Schedule UpdateScan, UpdateEval -ComputerName $FQDN
                Start-Sleep -Seconds 120
                #endregion Force a couple of update checks and wait 2 minutes

                #region Check for updates and insert into SQL appropriately
                Write-CMLogEntry "Checking CCM_SoftwareUpdate for missing updates that are with a filter `"NOT Name LIKE '%Definition%' and ComplianceState=0`""
                [System.Management.ManagementObject[]]$MissingUpdates = Get-WmiObject -Class CCM_SoftwareUpdate -Filter "NOT Name LIKE '%Definition%' and ComplianceState=0" -Namespace root\CCM\ClientSDK -ComputerName $FQDN -Credential $RemotingCreds -ErrorAction Stop
                if ($MissingUpdates -is [Object]) {
                    $PatchCount = $MissingUpdates.Count
                    Write-CMLogEntry "Found $PatchCount for $ComputerName"
                    Foreach ($Update in $MissingUpdates) {
                        if (($Update.ComplianceState -match "^0$|^2$") -and ($Update.EvaluationState -match "^0$|^1$|^13$")) {
                            if (Get-UpdateFromDB -ArticleID $Update.ArticleID) {
                                Set-UpdateInDB -Action Update -ArticleID $Update.ArticleID -ComplianceState $Update.ComplianceState -EvaluationState $Update.EvaluationState
                            }
                            else {
                                $AssignmentID = Get-CimInstance -CimSession $CIMSession -Classname CCM_TargetedUpdateEx1 -Namespace Root\ccm\softwareupdates\deploymentagent -Filter "UpdateId = '$($Update.UpdateID)'" | Select-Object -ExpandProperty RefAssignments -Unique
                                Set-UpdateInDB -Action Insert -ArticleID $Update.ArticleID -ComplianceState $Update.ComplianceState -EvaluationState $Update.EvaluationState -AssignmentID $AssignmentID
                            }
                        }
                    }
                }
                #endregion Check for updates and insert into SQL appropriately
            }
            $MissingUpdatesQuery = [string]::Format("SELECT ArticleID from dbo.SoftwareUpdates where ServerName='{0}' AND ComplianceState = '0' AND RBInstance='{1}'", $ComputerName, $RBInstance)
            $startCompPatchQuerySplat = @{
                Query     = $MissingUpdatesQuery
                Log       = $true
                Folder    = $LogLocation
                Component = "[$ComputerName]::[$ScriptName]"
                Filename  = [string]::Format("{0}-{1}.log", $RBInstance, $ComputerName)
            }
            $UpdatesNeeded = Start-CompPatchQuery @startCompPatchQuerySplat 
            if (($UpdatesNeeded | Measure-Object).Count -eq 0) {
                Update-DBServerStatus -LastStatus "Round of patching executed"
                Write-CMLogEntry "No remaining updates for [ServerName=$ComputerName] [RBInstance=$RBInstance]"
                $Finished = $true
            }
            else {
                $PatchCount = ($UpdatesNeeded | Measure-Object).Count
                Update-DBServerStatus -LastStatus "$PatchCount Patches Remaining"
                foreach ($Update in $UpdatesNeeded) {
                    Write-CMLogEntry "Identified [ArticleID=$($Update.ArticleID)] for [ServerName=$ComputerName] [RBInstance=$RBInstance] that is not marked installed in the database"
                }
                $Finished = $false
            }
            #endregion iterate through missing updates, install as needed and note compliance in DB
        }
        else {
            Update-DBServerStatus -LastStatus 'Patching Skipped'
            if (-not $Patch) {
                Write-CMLogEntry -Value "Server identifed in DB as exception to patching. Will skip patching steps" -Severity 2    
            }
            if ($DryRun) {
                Write-CMLogEntry -Value "Performing DryRun. Will skip patching steps" -Severity 2    
            }
        
            $Finished = $true
        }

        #region check for pending reboot from SCCM
        $newLoopActionSplat = @{
            ExitCondition   = { $script:PendingReboot }
            LoopDelay       = 5
            LoopTimeoutType = 'Minutes'
            LoopTimeout     = 1
            ScriptBlock     = { $script:PendingReboot = Get-PendingSCCMReboot -ComputerName $script:FQDN }
        }
        New-LoopAction @newLoopActionSplat
        Write-CMLogEntry "Pending reboot status [PendingReboot=$script:PendingReboot] [ServerName=$ComputerName]"
        #endregion check for pending reboot from SCCM
    }
    catch {
        # Catch any errors thrown above here, setting the result status and recording the error message to return to the activity for data bus publishing
        $ResultStatus = "Failed"
        $ErrorMessage = $error[0].Exception.Message
        $LastStatus = "Failed: $global:CurrentAction"
        Update-DBServerStatus -LastStatus $LastStatus
        Write-CMLogEntry "Exception caught during action [$global:CurrentAction]: $ErrorMessage" -Severity 3
    }
    finally {
        # Always do whatever is in the finally block. In this case, adding some additional detail about the outcome to the trace log for return
        if ($ErrorMessage.Length -gt 0) {
            Write-CMLogEntry "Exiting script with result [$ResultStatus] and error message [$ErrorMessage]" -Severity 3
        }
        else {
            $ResultStatus = 'Success'
            Write-CMLogEntry "Exiting script with [PendingReboot=$PendingReboot] [ResultStatus=$ResultStatus]"
        }
        if ($CIMSession) {
            $CIMSession.Close()
        }
    }

    # Record end of activity script process
    Update-DBServerStatus -Status "Finished $ScriptName"
    Update-DBServerStatus -Stage 'End' -Component $ScriptName
    Write-CMLogEntry "Script finished"
}