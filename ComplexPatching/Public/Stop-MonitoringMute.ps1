param
(
    [parameter(Mandatory = $true)]
    [string]$ComputerName,
    # Provides the computer name to check services on

    [parameter(Mandatory = $true)]
    [string]$DryRun,
    # skips patching check so that we can perform a dry run of the drain an resume

    [parameter(Mandatory = $true)]
    [int32]$RBInstance,
    # RBInstance which represents the Runbook Process ID for this runbook workflow

    [parameter(Mandatory = $false)]
    [string]$WasMuted,
    # Boolean to pass along if this server was muted prior to the patching process

    [parameter(Mandatory = $true)]
    [string]$SQLServer,
    # Database server for staging information during the patching process

    [parameter(Mandatory = $true)]
    [string]$OrchStagingDB,
    # Database for staging information during the patching process

    [parameter(Mandatory = $true)]
    [string]$SolarwindsURI,
    # URI for Solarwinds which will allow us to mute alerts for a period of time

    [parameter(Mandatory = $true)]
    [string]$LogLocation
    # UNC path to store log files in
)

#region import modules
Import-Module -Name ComplexPatching
#endregion import modules

#-----------------------------------------------------------------------

## Initialize result and trace variables
# $ResultStatus provides basic success/failed indicator
# $ErrorMessage captures any error text generated by script
# $Trace is used to record a running log of actions
[bool]$DryRun = ConvertTo-Boolean $DryRun
$ErrorMessage = ""
$global:CurrentAction = ""
$ScriptName = $((Split-Path $PSCommandPath -Leaf) -Replace '.ps1', $null)

#region set our defaults for the our functions
#region Write-CMLogEntry defaults
$Bias = Get-WmiObject -Class Win32_TimeZone | Select-Object -ExpandProperty Bias
$PSDefaultParameterValues.Add("Write-CMLogEntry:Bias", $Bias)
$PSDefaultParameterValues.Add("Write-CMLogEntry:FileName", [string]::Format("{0}-{1}.log", $RBInstance, $ComputerName))
$PSDefaultParameterValues.Add("Write-CMLogEntry:Folder", $LogLocation)
$PSDefaultParameterValues.Add("Write-CMLogEntry:Component", "[$ComputerName]::[$ScriptName]")
#endregion Write-CMLogEntry defaults

#region Update-DBServerStatus defaults
$PSDefaultParameterValues.Add("Update-DBServerStatus:ComputerName", $ComputerName)
$PSDefaultParameterValues.Add("Update-DBServerStatus:RBInstance", $RBInstance)
$PSDefaultParameterValues.Add("Update-DBServerStatus:SQLServer", $SQLServer)
$PSDefaultParameterValues.Add("Update-DBServerStatus:Database", $OrchStagingDB)
#endregion Update-DBServerStatus defaults

#region Start-CompPatchQuery defaults
$PSDefaultParameterValues.Add("Start-CompPatchQuery:SQLServer", $SQLServer)
$PSDefaultParameterValues.Add("Start-CompPatchQuery:Database", $OrchStagingDB)
#endregion Start-CompPatchQuery defaults
#endregion set our defaults for our functions

Write-CMLogEntry "Runbook activity script started - [Running On = $env:ComputerName]"
Update-DBServerStatus -Status "Started $ScriptName"
Update-DBServerStatus -Stage 'Start' -Component $ScriptName -DryRun $DryRun

if ($PSBoundParameters.ContainsKey('WasMuted')) {
    [bool]$WasMuted = [System.Convert]::ToBoolean($WasMuted)
}
else {
    [bool]$WasMuted = $false
}

try {
    #region modules
    Write-CMLogEntry "Importing SwisPowerShell module"
    Import-Module -Name SwisPowerShell -ErrorAction Stop
    Write-CMLogEntry "SwisPowerShell module imported"
    #endregion modules

    #region create credential objects
    Write-CMLogEntry "Creating necessary credential objects"
    $NMSCreds = Get-StoredCredential -Purpose Solarwinds -SQLServer $SQLServer -Database $OrchStagingDB
    #endregion create credential objects

    #region connect to Solarwinds
    Write-CMLogEntry "Connecting to Solarwinds at $SolarwindsURI"
    $SWIS = Connect-SWIS -Hostname $SolarwindsURI -Credential $NMSCreds -ErrorAction Stop
    Write-CMLogEntry "Connected to Solarwinds at $SolarwindsURI"
    #endregion connect to Solarwinds

    #region query current status of alerts
    Write-CMLogEntry "Querying Solarwinds for $ComputerName"
    $Node = Get-SwisData -SwisConnection $SWIS -Query @"
SELECT Caption, IP_Address, Uri AS [EntityUri]
FROM Orion.Nodes
WHERE  Caption = '$ComputerName'
    AND Vendor = 'Windows'
    AND ObjectSubType IN ( 'Agent', 'WMI' )
ORDER BY Caption
"@ -ErrorAction Stop
    if ($Node.Caption -eq $ComputerName) {
        Write-CMLogEntry "Identified $($Node.Caption) in Solarwinds"

        Write-CMLogEntry "Querying for suppresion of alerts for $($Node.Caption) in Solarwinds"
        $Suppression = Get-SwisData -SwisConnection $SWIS -Query @"
SELECT EntityUri, SuppressFrom, SuppressUntil
FROM Orion.AlertSuppression
WHERE EntityUri = '$( $Node.EntityUri )'
"@ -ErrorAction Stop

        $Now = Get-Date
        $Muted = $false
        if ($Suppression) {
            if ($Now -gt $Suppression.SuppressFrom.ToLocalTime() -and $Now -lt $Suppression.SuppressUntil.ToLocalTime()) {
                $Muted = $true
            }
        }
        Write-CMLogEntry "$ComputerName identified in Solarwinds with status [Muted=$Muted]"
        #endregion query current status of alerts

        #region unmute alerts if we performed the mute in the beginning
        if ($Muted -and !$WasMuted) {
            Update-DBServerStatus -LastStatus "Unsuppressing Alerts"
            New-LoopAction -LoopTimeout 2 -LoopTimeoutType Minutes -LoopDelay 15 -LoopDelayType Seconds -ScriptBlock {
                try {
                    Invoke-SwisVerb -SwisConnection $script:SWIS -EntityName Orion.AlertSuppression -Verb ResumeAlerts -Arguments @(, @($script:Node.EntityURI) ) -ErrorAction Stop
                    $Muted = $false
                }
                catch {
                    $Muted = $true
                }
            } -ExitCondition { !$Muted } -IfTimeoutScript { throw "Failed to resumse alerts for $ComputerName" }
        }
        else {
            Write-CMLogEntry "Will not touch alert muting because the change was not made by Orchestrator"
        }
        Write-CMLogEntry "$ComputerName alerts were unmuted"
    }
    else {
        Write-CMLogEntry "Did not find $ComputerName in Solarwinds"
    }

    $ResultStatus = 'Success'
    #region unmute alerts if we performed the mute in the beginning
}
catch {
    # Catch any errors thrown above here, setting the result status and recording the error message to return to the activity for data bus publishing
    $ResultStatus = "Failed"
    $ErrorMessage = $error[0].Exception.Message
    Write-CMLogEntry "Exception caught during action [$global:CurrentAction]: $ErrorMessage" -Severity 3
    Update-DBServerStatus -LastStatus 'Alert UnMute Failed'
}
finally {
    # Always do whatever is in the finally block. In this case, adding some additional detail about the outcome to the trace log for return
    if ($ErrorMessage.Length -gt 0) {
        $ResultStatus = 'Failed'
        Write-CMLogEntry "Exiting script with result [$ResultStatus] and error message [$ErrorMessage]" -Severity 3
    }
    else {
        Write-CMLogEntry "Exiting script with result [$ResultStatus]"
        Update-DBServerStatus -LastStatus 'Alerts UnMuted'
    }
}
# Record end of activity script process
Update-DBServerStatus -Status "Finished $ScriptName"
Update-DBServerStatus -Stage 'End' -Component $ScriptName
Write-CMLogEntry "Script finished"