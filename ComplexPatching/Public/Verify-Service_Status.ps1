function Verify-Service_Status {
    param
    (
        [parameter(Mandatory = $true)]
        [string]$ComputerName,
        # Provides the computer name to check services on

        [parameter(Mandatory = $true)]
        [string]$DryRun,
        # skips patching check so that we can perform a dry run of the drain an resume

        [parameter(Mandatory = $true)]
        [int32]$RBInstance,
        # RBInstance which represents the Runbook Process ID for this runbook workflow

        [parameter(Mandatory = $true)]
        [string]$SQLServer,
        # Database server for staging information during the patching process

        [parameter(Mandatory = $true)]
        [string]$OrchStagingDB,
        # Database for staging information during the patching process

        [parameter(Mandatory = $true)]
        [string]$LogLocation
        # UNC path to store log files in
    )

    #region import modules
    Import-Module -Name ComplexPatching
    #endregion import modules

    #-----------------------------------------------------------------------

    ## Initialize result and trace variables
    # $ResultStatus provides basic success/failed indicator
    # $ErrorMessage captures any error text generated by script
    # $Trace is used to record a running log of actions
    [bool]$DryRun = ConvertTo-Boolean $DryRun
    $ErrorMessage = ""
    $global:CurrentAction = ""
    $ScriptName = $((Split-Path $PSCommandPath -Leaf) -Replace '.ps1', $null)

    #region set our defaults for the our functions
    #region Write-CMLogEntry defaults
    $Bias = Get-WmiObject -Class Win32_TimeZone | Select-Object -ExpandProperty Bias
    $PSDefaultParameterValues.Add("Write-CMLogEntry:Bias", $Bias)
    $PSDefaultParameterValues.Add("Write-CMLogEntry:FileName", [string]::Format("{0}-{1}.log", $RBInstance, $ComputerName))
    $PSDefaultParameterValues.Add("Write-CMLogEntry:Folder", $LogLocation)
    $PSDefaultParameterValues.Add("Write-CMLogEntry:Component", "[$ComputerName]::[$ScriptName]")
    #endregion Write-CMLogEntry defaults

    #region Update-DBServerStatus defaults
    $PSDefaultParameterValues.Add("Update-DBServerStatus:ComputerName", $ComputerName)
    $PSDefaultParameterValues.Add("Update-DBServerStatus:RBInstance", $RBInstance)
    $PSDefaultParameterValues.Add("Update-DBServerStatus:SQLServer", $SQLServer)
    $PSDefaultParameterValues.Add("Update-DBServerStatus:Database", $OrchStagingDB)
    #endregion Update-DBServerStatus defaults

    #region Start-CompPatchQuery defaults
    $PSDefaultParameterValues.Add("Start-CompPatchQuery:SQLServer", $SQLServer)
    $PSDefaultParameterValues.Add("Start-CompPatchQuery:Database", $OrchStagingDB)
    #endregion Start-CompPatchQuery defaults
    #endregion set our defaults for our functions

    Write-CMLogEntry "Runbook activity script started - [Running On = $env:ComputerName]"
    Update-DBServerStatus -Status "Started $ScriptName"
    Update-DBServerStatus -Stage 'Start' -Component $ScriptName -DryRun $DryRun

    try {
        #region create credential objects
        Write-CMLogEntry "Creating necessary credential objects"
        $RemotingCreds = Get-StoredCredential -ComputerName $ComputerName -SQLServer $SQLServer -Database $OrchStagingDB
        #endregion create credential objects

        $FQDN = Get-FQDNFromDB -ComputerName $ComputerName -SQLServer $SQLServer -Database $OrchStagingDB

        #region initiate CIMSession, looping until one is made, or it has been 10 minutes
        Update-DBServerStatus -LastStatus 'Creating CIMSession'
        Write-CMLogEntry 'Creating CIMSession'
        New-LoopAction -LoopTimeout 10 -LoopTimeoutType Minutes -LoopDelay 10 -ExitCondition { $script:CIMSession } -ScriptBlock {
            $script:CIMSession = New-MrCimSession -Credential $script:RemotingCreds -ComputerName $script:FQDN
        } -IfSucceedScript { 
            Update-DBServerStatus -LastStatus "CIMSession Created"
            Write-CMLogEntry 'CIMSession created succesfully' 
        } -IfTimeoutScript {
            Write-CMLogEntry 'Failed to create CIMSession'
            throw 'Failed to create CIMsession'
        }
        #endregion initiate CIMSession, looping until one is made, or it has been 10 minutes

        #region query the current state of based services and compare to the DB
        try {
            Write-CMLogEntry "Comparing current service state, and initial service state recorded in the DB"
            $ServiceStateQuery = [string]::Format("Select ServiceName AS Name, Status AS State, StartupType AS StartMode from [dbo].[Service] where ServerName='{0}' and RBInstance='{1}'", $ComputerName, $RBInstance)
            $DesiredServiceState = Start-CompPatchQuery -Query $ServiceStateQuery | Select-Object -Property Name, State, StartMode
            $DBCount = $DesiredServiceState | Measure-Object | Select-Object -ExpandProperty Count
            if ($DBCount -ne 0) {
                Write-CMLogEntry "[ServiceStrings=$($DesiredServiceState.Name -join ';')] [Count=$DBCount]"
            }
            else {
                Write-CMLogEntry "No services found in DB for $ComputerName"
                $ResultStatus = 'Success'
            }
        }
        catch {
            Write-CMLogEntry "No services found in DB for $ComputerName"
            $ResultStatus = 'Success'
        }

        if ($null -ne $DesiredServiceState) {
            Update-DBServerStatus -LastStatus "Verifying Services"
            New-LoopAction -LoopTimeout 10 -LoopTimeoutType Minutes -LoopDelay 30 -ExitCondition { $script:ResultStatus -eq 'Success' } -ScriptBlock {
                $Services = [System.Collections.ArrayList]::new()
                foreach ($S in $script:DesiredServiceState) {
                    $ServiceName = $S.Name
                    $Service = Get-CimInstance -CimSession $script:CIMSession -ClassName Win32_Service -Filter "Name = '$ServiceName'"
                    if ($null -ne $Service) {
                        Write-CMLogEntry "Service Identified - [Name=$($Service.Name)] [State=$($Service.State)]"
                        if (!$Service.Started) {
                            Write-CMLogEntry -Value "Attempting to start $($Service.Name)" -Severity 2
                            $Service | Invoke-CimMethod -MethodName StartService
                        }
                        else {
                            $Services.Add(($Service | Select-Object -Property Name, State, StartMode)) | Out-Null
                        }
                    }
                }
                if ($null -ne $Services) {
                    $Comparison = Compare-Object -ReferenceObject $Services -DifferenceObject $DesiredServiceState -ErrorAction SilentlyContinue
                    if ($null -eq $Comparison) {
                        $script:ResultStatus = 'Success'
                    }
                    else {
                        Write-CMLogEntry "Waiting on $($Comparison | Measure-Object | Select-Object -ExpandProperty Count) services to start"
                    }
                }
            } -IfTimeoutScript {
                throw "Failed to verify services for [ServerName=$script:ComputerName] after 10 minutes"
            } -IfSucceedScript {
                Update-DBServerStatus -LastStatus "Services Verified"
                Write-CMLogEntry "Verified services succesfully"
            }
        }
        #endregion query the current state of services and compare to the DB
    }
    catch {
        # Catch any errors thrown above here, setting the result status and recording the error message to return to the activity for data bus publishing
        $ResultStatus = "Failed"
        $ErrorMessage = $error[0].Exception.Message
        Write-CMLogEntry "Exception caught during action [$global:CurrentAction]: $ErrorMessage" -Severity 3
    }
    finally {
        # Always do whatever is in the finally block. In this case, adding some additional detail about the outcome to the trace log for return
        if ($ErrorMessage.Length -gt 0) {
            $ResultStatus = 'Failed'
            Write-CMLogEntry "Exiting script with result [$ResultStatus] and error message [$ErrorMessage]" -Severity 3
        }
        else {
            Write-CMLogEntry "Exiting script with result [$ResultStatus]"
        }
        if ($CIMSession) {
            $CIMSession.Close()
        }
    }
    # Record end of activity script process
    Update-DBServerStatus -Status "Finished $ScriptName"
    Update-DBServerStatus -Stage 'End' -Component $ScriptName
    Write-CMLogEntry "Script finished"
}