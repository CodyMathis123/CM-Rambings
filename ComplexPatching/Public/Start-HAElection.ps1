param
(
    [parameter(Mandatory = $true)]
    [string]$Grouping,
    # Server grouping which we are looking to perform failover on

    [parameter(Mandatory = $true)]
    [int32]$RBInstance,
    # RBInstance which represents the Runbook Process ID for this runbook workflow

    [parameter(Mandatory = $true)]
    [string]$SQLServer,
    # Database server for staging information during the patching process

    [parameter(Mandatory = $true)]
    [string]$OrchStagingDB,
    # Database for staging information during the patching process

    [parameter(Mandatory = $true)]
    [string]$LogLocation
    # UNC path to store log files in
)

#region import modules
Import-Module -Name ComplexPatching
#endregion import modules

#-----------------------------------------------------------------------

## Initialize result and trace variables
# $ResultStatus provides basic success/failed indicator
# $ErrorMessage captures any error text generated by script
# $Trace is used to record a running log of actions
$ErrorMessage = ''
$global:CurrentAction = ''
$ScriptName = $((Split-Path $PSCommandPath -Leaf) -Replace '.ps1', $null)

##region set our defaults for the our functions
#region Write-CMLogEntry defaults
$Bias = Get-WmiObject -Class Win32_TimeZone | Select-Object -ExpandProperty Bias
$PSDefaultParameterValues.Add("Write-CMLogEntry:Bias", $Bias)
$PSDefaultParameterValues.Add("Write-CMLogEntry:FileName", [string]::Format("{0}-{1}.log", $RBInstance, $Grouping))
$PSDefaultParameterValues.Add("Write-CMLogEntry:Folder", $LogLocation)
$PSDefaultParameterValues.Add("Write-CMLogEntry:Component", "[$Grouping]::[$ScriptName]")
#endregion Write-CMLogEntry defaults

#region Start-CompPatchQuery defaults
$PSDefaultParameterValues.Add("Start-CompPatchQuery:SQLServer", $SQLServer)
$PSDefaultParameterValues.Add("Start-CompPatchQuery:Database", $OrchStagingDB)
#endregion Start-CompPatchQuery defaults
#endregion set our defaults for our functions

Write-CMLogEntry "Runbook activity script started - [Running On = $env:ComputerName]"

try {
    #region query all HA instances
    Write-CMLogEntry "Querying $OrchStagingDB for all servers with [PatchStrategy = 'SQL-HA']"
    $HASQLInfoQuery = [string]::Format("SELECT * FROM [dbo].[ServerStatus] WHERE PatchStrategy = 'SQL-HA' AND Grouping = '{0}'", $Grouping)
    $HASQLInfo = Start-CompPatchQuery -Query $HASQLInfoQuery
    Write-CMLogEntry "Querying a random server from [Grouping=$Grouping] availability group to get group info"
    $ServerToQuery = Get-Random -InputObject ($HASQLInfo.where{ $_.Grouping -eq $Grouping }).ServerName
    $FQDN = Get-FQDNFromDB -ComputerName $ServerToQuery -SQLServer $SQLServer -Database $OrchStagingDB
    $CurrentHAInfo = Invoke-SQLcmd2 -ServerInstance $FQDN -Query "SELECT replica_server_name,CASE
    WHEN replica_server_name=ag.primary_replica THEN 'PRIMARY' ELSE 'SECONDARY'END [Status]
    ,synchronization_health_desc,g.name,failover_mode_desc,secondary_role_allow_connections_desc ReadableSec
    FROM sys.availability_replicas r INNER JOIN [sys].[availability_groups] g
    ON r.group_id=g.group_id LEFT JOIN [master].[sys].[dm_hadr_availability_group_states] ag
    ON r.group_id=ag.group_id
    WHERE failover_mode_desc = 'AUTOMATIC'
    ORDER BY 2"

    if ($null -ne $CurrentHAInfo -and $CurrentHAInfo.Count -ge 2) {
        foreach ($Node in $CurrentHAInfo) {
            Write-CMLogEntry "NODE::[ServerName=$($Node.'replica_server_name')] [Status=$($Node.Status)] [AvailabilityGroupName=$($Node.name)] [Health=$($Node.'synchronization_health_desc')]"
        }

        $NonHealthy = $CurrentHAInfo | Where-Object { $_.'synchronization_health_desc' -ne 'HEALTHY' }

        if ($null -eq $NonHealthy) {
            Write-CMLogEntry "All availability groups are healthy"
            Write-CMLogEntry "Determining what groups need failover"
            $Info = New-Object System.Collections.ArrayList
            foreach ($Server in ($CurrentHAinfo | Select-Object -ExpandProperty 'replica_server_name' -Unique)) {
                $PrimaryCount = $CurrentHAinfo | Where-Object { $_.'replica_server_name' -eq $Server -and $_.Status -eq 'PRIMARY' } | Measure-Object | Select-Object -ExpandProperty count
                $SecondaryCount = $CurrentHAinfo | Where-Object { $_.'replica_server_name' -eq $Server -and $_.Status -eq 'SECONDARY' } | Measure-Object | Select-Object -ExpandProperty count
                if ($PrimaryCount -eq 0) {
                    $obj = [PSCustomObject]@{
                        Server           = $Server;
                        Grouping         = $HASQLInfo | Where-Object { $_.ServerName -eq $Server } | Select-Object -ExpandProperty Grouping
                        Tier             = 2
                        FailOverNeeded   = $false
                        FailOverCount    = 0
                        Majority         = 'Secondary'
                        GroupsToFailover = 'NONE'
                    }
                }
                elseif ($SecondaryCount -eq 0) {
                    $obj = [PSCustomObject]@{
                        Server           = $Server;
                        Grouping         = $HASQLInfo | Where-Object { $_.ServerName -eq $Server } | Select-Object -ExpandProperty Grouping
                        Tier             = 1
                        FailOverNeeded   = $false
                        FailOverCount    = 0
                        Majority         = 'Primary'
                        GroupsToFailover = 'NONE'
                    }
                }
                else {
                    if ($SecondaryCount -gt $PrimaryCount) {
                        $obj = [PSCustomObject]@{
                            Server           = $Server;
                            Grouping         = $HASQLInfo | Where-Object { $_.ServerName -eq $Server } | Select-Object -ExpandProperty Grouping
                            Tier             = 2
                            FailOverNeeded   = $true
                            FailOverCount    = $PrimaryCount
                            Majority         = 'Secondary'
                            GroupsToFailover = $CurrentHAinfo | Where-Object { $_.'replica_server_name' -eq $Server -and $_.Status -eq 'PRIMARY' } | Select-Object -ExpandProperty Name
                        }
                    }
                    elseif ($SecondaryCount -lt $PrimaryCount) {
                        $obj = [PSCustomObject]@{
                            Server           = $Server;
                            Grouping         = $HASQLInfo | Where-Object { $_.ServerName -eq $Server } | Select-Object -ExpandProperty Grouping
                            Tier             = 1
                            FailOverNeeded   = $true
                            FailOverCount    = $PrimaryCount
                            Majority         = 'Primary'
                            GroupsToFailover = $CurrentHAinfo | Where-Object { $_.'replica_server_name' -eq $Server -and $_.Status -eq 'PRIMARY' } | Select-Object -ExpandProperty Name
                        }
                    }
                    elseif ($PrimaryCount -eq $SecondaryCount) {
                        $Grouping = $HASQLInfo | Where-Object { $_.ServerName -eq $Server } | Select-Object -ExpandProperty Grouping
                        if ($Info | Where-Object { $_.Grouping -eq $Grouping -and $_.Tier -eq 1 }) {
                            $Tier = 2
                        }
                        else {
                            $Tier = 1
                        }
                        $obj = [PSCustomObject]@{
                            Server           = $Server;
                            Grouping         = $Grouping
                            Tier             = $Tier
                            FailOverNeeded   = $true
                            FailOverCount    = $PrimaryCount
                            Majority         = 'EQUAL'
                            GroupsToFailover = $CurrentHAinfo | Where-Object { $_.'replica_server_name' -eq $Server -and $_.Status -eq 'PRIMARY' } | Select-Object -ExpandProperty Name
                        }
                    }
                    else {
                        $obj = [PSCustomObject]@{
                            Server           = $Server;
                            Grouping         = $HASQLInfo | Where-Object { $_.ServerName -eq $Server } | Select-Object -ExpandProperty Grouping
                            Tier             = 2
                            FailOverNeeded   = $false
                            FailOverCount    = 0
                            Majority         = 'Equal'
                            GroupsToFailover = 'NONE'
                        }
                    }
                }
                Write-CMLogEntry "INFO::[ServerName=$($obj.Server)] [Grouping=$($obj.Grouping)] [Tier=$($obj.Tier)] [FailOverNeeded=$($obj.FailOverNeeded)] [FailOverCount=$($obj.FailOverCount)] [Majority=$($obj.Majority)] [GroupsToFailover=$($obj.GroupsToFailover -join ';')]"
                $Info.Add($obj) | Out-Null
            }
            #endregion query all HA instances

            if ($Info.FailOverNeeded -contains $true) {
                #region failover as needed
                Write-CMLogEntry "At least one availability group requires failover"
                foreach ($SQLHAgroup in ($Info | Where-Object { $_.FailOverNeeded -and $_.Tier -eq 2 })) {
                    $SQLGroup = $SQLHAgroup | Select-Object -ExpandProperty GroupsToFailover
                    foreach ($Group in $SQLgroup) {
                        $SecondaryServer = $CurrentHAInfo | Where-Object { $_.Name -eq $Group -and $_.Status -eq 'Secondary' } | Select-Object -ExpandProperty 'replica_server_name'
                        Write-CMLogEntry "Performing failover - executing [ALTER AVAILABILITY GROUP [$Group] FAILOVER;] against $SecondaryServer"
                        Invoke-SQLcmd2 -ServerInstance $SecondaryServer -Query "ALTER AVAILABILITY GROUP [$Group] FAILOVER;"
                    }
                }
                #endregion failover as needed

                #region query all HA instances
                $HASQLInfoQuery = [string]::Format("SELECT * FROM [dbo].[ServerStatus] WHERE PatchStrategy = 'SQL-HA' AND Grouping = '{0}'", $Grouping)
                $HASQLInfo = Start-CompPatchQuery -Query $HASQLInfoQuery
                Write-CMLogEntry "Querying a random server from [Grouping=$Grouping] availability group to get group info"
                $ServerToQuery = Get-Random -InputObject ($HASQLInfo.where{ $_.Grouping -eq $Grouping }).ServerName
                $FQDN = Get-FQDNFromDB -ComputerName $ServerToQuery -SQLServer $SQLServer -Database $OrchStagingDB
                $CurrentHAInfo = Invoke-SQLcmd2 -ServerInstance $FQDN -Query "SELECT replica_server_name,CASE
                WHEN replica_server_name=ag.primary_replica THEN 'PRIMARY' ELSE 'SECONDARY'END [Status]
                ,synchronization_health_desc,g.name,failover_mode_desc,secondary_role_allow_connections_desc ReadableSec
                FROM sys.availability_replicas r INNER JOIN [sys].[availability_groups] g
                ON r.group_id=g.group_id LEFT JOIN [master].[sys].[dm_hadr_availability_group_states] ag
                ON r.group_id=ag.group_id
                WHERE failover_mode_desc = 'AUTOMATIC'
                ORDER BY 2"

                $Info = New-Object System.Collections.ArrayList
                foreach ($Server in ($CurrentHAinfo | Select-Object -ExpandProperty 'replica_server_name' -Unique)) {
                    $PrimaryCount = $CurrentHAinfo | Where-Object { $_.'replica_server_name' -eq $Server -and $_.Status -eq 'PRIMARY' } | Measure-Object | Select-Object -ExpandProperty count
                    $SecondaryCount = $CurrentHAinfo | Where-Object { $_.'replica_server_name' -eq $Server -and $_.Status -eq 'SECONDARY' } | Measure-Object | Select-Object -ExpandProperty count
                    if ($PrimaryCount -eq 0) {
                        $obj = [PSCustomObject]@{
                            Server           = $Server;
                            Grouping         = $HASQLInfo | Where-Object { $_.ServerName -eq $Server } | Select-Object -ExpandProperty Grouping
                            Tier             = 2
                            FailOverNeeded   = $false
                            FailOverCount    = 0
                            Majority         = 'Secondary'
                            GroupsToFailover = 'NONE'
                        }
                    }
                    elseif ($SecondaryCount -eq 0) {
                        $obj = [PSCustomObject]@{
                            Server           = $Server;
                            Grouping         = $HASQLInfo | Where-Object { $_.ServerName -eq $Server } | Select-Object -ExpandProperty Grouping
                            Tier             = 1
                            FailOverNeeded   = $false
                            FailOverCount    = 0
                            Majority         = 'Primary'
                            GroupsToFailover = 'NONE'
                        }
                    }
                    else {
                        if ($SecondaryCount -gt $PrimaryCount) {
                            $obj = [PSCustomObject]@{
                                Server           = $Server;
                                Grouping         = $HASQLInfo | Where-Object { $_.ServerName -eq $Server } | Select-Object -ExpandProperty Grouping
                                Tier             = 2
                                FailOverNeeded   = $true
                                FailOverCount    = $PrimaryCount
                                Majority         = 'Secondary'
                                GroupsToFailover = $CurrentHAinfo | Where-Object { $_.'replica_server_name' -eq $Server -and $_.Status -eq 'PRIMARY' } | Select-Object -ExpandProperty Name
                            }
                        }
                        elseif ($SecondaryCount -lt $PrimaryCount) {
                            $obj = [PSCustomObject]@{
                                Server           = $Server;
                                Grouping         = $HASQLInfo | Where-Object { $_.ServerName -eq $Server } | Select-Object -ExpandProperty Grouping
                                Tier             = 1
                                FailOverNeeded   = $true
                                FailOverCount    = $PrimaryCount
                                Majority         = 'Primary'
                                GroupsToFailover = $CurrentHAinfo | Where-Object { $_.'replica_server_name' -eq $Server -and $_.Status -eq 'PRIMARY' } | Select-Object -ExpandProperty Name
                            }
                        }
                        elseif ($PrimaryCount -eq $SecondaryCount) {
                            $Grouping = $HASQLInfo | Where-Object { $_.ServerName -eq $Server } | Select-Object -ExpandProperty Grouping
                            if ($Info | Where-Object { $_.Grouping -eq $Grouping -and $_.Tier -eq 1 }) {
                                $Tier = 2
                            }
                            else {
                                $Tier = 1
                            }
                            $obj = [PSCustomObject]@{
                                Server           = $Server;
                                Grouping         = $Grouping
                                Tier             = $Tier
                                FailOverNeeded   = $true
                                FailOverCount    = $PrimaryCount
                                Majority         = 'EQUAL'
                                GroupsToFailover = $CurrentHAinfo | Where-Object { $_.'replica_server_name' -eq $Server -and $_.Status -eq 'PRIMARY' } | Select-Object -ExpandProperty Name
                            }
                        }
                        else {
                            $obj = [PSCustomObject]@{
                                Server           = $Server;
                                Grouping         = $HASQLInfo | Where-Object { $_.ServerName -eq $Server } | Select-Object -ExpandProperty Grouping
                                Tier             = 2
                                FailOverNeeded   = $false
                                FailOverCount    = 0
                                Majority         = 'Equal'
                                GroupsToFailover = 'NONE'
                            }
                        }
                    }
                    $Info.Add($obj) | Out-Null
                }
                #endregion query all HA instances

                if ($Info.FailOverNeeded -contains $true) {
                    Write-CMLogEntry -Value "Failover still needed on at least one SQL HA Instance" -Severity 3
                    throw "Failover still needed on at least one SQL HA Instance"
                }
                else {
                    Write-CMLogEntry "Failover complete for all availability groups"
                    foreach ($Server in $Info) {
                        Write-CMLogEntry "Updating $OrchStagingDB [ServerName=$($Server.Server)] [Tier=$($Server.Tier)]"
                        $SetTierQuery = [string]::Format("UPDATE [dbo].[ServerStatus] SET Tier = {0} WHERE ServerName = '{1}'", $Server.Tier, $Server.Server)
                        Start-CompPatchQuery -Query $SetTierQuery
                    }
                    $ResultStatus = 'Success'
                }
            }
            else {
                Write-CMLogEntry "Determined that all availability groups are in a desired state, no failover needed"
                foreach ($Server in $Info) {
                    $SetTierQuery = [string]::Format("UPDATE [dbo].[ServerStatus] SET Tier = {0} WHERE ServerName = '{1}'", $Server.Tier, $Server.Server)
                    Start-CompPatchQuery -Query $SetTierQuery
                }
                $ResultStatus = 'Success'
            }
        }
        else {
            Write-CMLogEntry -Value "Determined that at least one availability groups synchronization health is not 'HEALTHY'" -Severity 3
            throw "Determined that at least one availability groups synchronization health is not 'HEALTHY'"
        }
    }
    else {
        if ($CurrentHAInfo.Count -lt 2) {
            Write-CMLogEntry -Value "There is less than 2 servers in this group. Will not perform patching" -Severity 3
            throw "There is less than 2 servers in this group. Will not perform patching"
        }
        if ($null -eq $CurrentHAInfo) {
            Write-CMLogEntry -Value "Failed to identify servers and their respective roles" -Severity 3
            throw "Failed to identify servers and their respective roles"
        }
    }
}
catch {
    # Catch any errors thrown above here, setting the result status and recording the error message to return to the activity for data bus publishing
    $ResultStatus = "Failed"
    $ErrorMessage = $error[0].Exception.Message
    $LastStatus = "Failed: $global:CurrentAction"
    [string]$Now = [System.TimeZoneInfo]::ConvertTimeBySystemTimeZoneId((Get-Date), 'Eastern Standard Time')
    $NoteFailureQuery = [string]::Format("UPDATE [dbo].[ServerStatus] SET LastStatus='{0}', TimeStamp='{1}' WHERE Grouping='{2}'", $LastStatus, $Now, $Grouping)
    Start-CompPatchQuery -Query $NoteFailureQuery
    Write-CMLogEntry "Exception caught during action [$global:CurrentAction]: $ErrorMessage" -Severity 3
}
finally {
    # Always do whatever is in the finally block. In this case, adding some additional detail about the outcome to the trace log for return
    if ($ErrorMessage.Length -gt 0) {
        Write-CMLogEntry "Exiting script with result [$ResultStatus] and error message [$ErrorMessage]" -Severity 3
    }
    else {
        Write-CMLogEntry "Exiting script with result [$ResultStatus]"
    }
}
# Record end of activity script process
Write-CMLogEntry "Script finished"