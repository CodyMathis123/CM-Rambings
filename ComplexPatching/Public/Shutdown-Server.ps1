param
(
    [parameter(Mandatory = $true)]
    [string]$ComputerName,
    # Provides the computer name to shutdown

    [parameter(Mandatory = $true)]
    [string]$DryRun,
    # skips patching check so that we can perform a dry run of the drain an resume

    [parameter(Mandatory = $true)]
    [int32]$RBInstance,
    # RBInstance which represents the Runbook Process ID for this runbook workflow

    [parameter(Mandatory = $true)]
    [string]$SQLServer,
    # Database server for staging information during the patching process

    [parameter(Mandatory = $true)]
    [string]$OrchStagingDB,
    # Database for staging information during the patching process

    [parameter(Mandatory = $true)]
    [array]$VIServers,
    # List of semicolon separated VIservers for connecting to vCenter

    [parameter(Mandatory = $true)]
    [string]$LogLocation
    # UNC path to store log files in
)

#region import modules
Import-Module -Name ComplexPatching
#endregion import modules

#-----------------------------------------------------------------------

## Initialize result and trace variables
# $ResultStatus provides basic success/failed indicator
# $ErrorMessage captures any error text generated by script
# $Trace is used to record a running log of actions
[bool]$DryRun = ConvertTo-Boolean $DryRun
$ResultStatus = ""
$ErrorMessage = ""
$global:CurrentAction = ""
$script:Shutdown = $false
$ScriptName = $((Split-Path $PSCommandPath -Leaf) -Replace '.ps1', $null)

#region set our defaults for the our functions
#region Write-CMLogEntry defaults
$Bias = Get-WmiObject -Class Win32_TimeZone | Select-Object -ExpandProperty Bias
$PSDefaultParameterValues.Add("Write-CMLogEntry:Bias", $Bias)
$PSDefaultParameterValues.Add("Write-CMLogEntry:FileName", [string]::Format("{0}-{1}.log", $RBInstance, $ComputerName))
$PSDefaultParameterValues.Add("Write-CMLogEntry:Folder", $LogLocation)
$PSDefaultParameterValues.Add("Write-CMLogEntry:Component", "[$ComputerName]::[$ScriptName]")
#endregion Write-CMLogEntry defaults

#region Update-DBServerStatus defaults
$PSDefaultParameterValues.Add("Update-DBServerStatus:ComputerName", $ComputerName)
$PSDefaultParameterValues.Add("Update-DBServerStatus:RBInstance", $RBInstance)
#endregion Update-DBServerStatus defaults

#region Start-CompPatchQuery defaults
$PSDefaultParameterValues.Add("Start-CompPatchQuery:SQLServer", $SQLServer)
$PSDefaultParameterValues.Add("Start-CompPatchQuery:Database", $OrchStagingDB)
#endregion Start-CompPatchQuery defaults
#endregion set our defaults for our functions

Write-CMLogEntry "Runbook activity script started - [Running On = $env:ComputerName]"
Update-DBServerStatus -Status "Started $ScriptName"
Update-DBServerStatus -Stage 'Start' -Component $ScriptName -DryRun $DryRun

try {
    #region modules
    if (!(Get-Module -Name 'vmware.powercli')) {
        Write-CMLogEntry "Import vmware.powercli module "
        Import-Module -Name 'vmware.powercli' -ErrorAction SilentlyContinue
    }
    #endregion modules

    #region connect to vmware
    Write-CMLogEntry "Connecting to VIServers $VIServers"
    Connect-Vcenter -Servers $VIServers
    #endregion connect to vmware

    #region create credential objects
    Write-CMLogEntry "Creating necessary credential objects"
    $RemotingCreds = Get-StoredCredential -ComputerName $ComputerName
    #endregion create credential objects

    $FQDN = Get-FQDNFromDB -ComputerName $ComputerName

    #region shutdown server - will calculate average time to shutdown, monitor status and force as needed
    #get average runtime, default to 900 seconds if a value is not found
    $AverageShutdownTimeQuery = [string]::Format("SELECT AVG(Duration) AS AverageDuration FROM [dbo].[v_ComponentDuration] WHERE [ServerName] = '{0}' AND [Component] = '{1}' AND [EndTime] IS NOT NULL AND [Duration] IS NOT NULL AND [DryRun] = '{2}'", $ComputerName, $ScriptName, $DryRun)
    $startCompPatchQuerySplat = @{
        Query     = $AverageShutdownTimeQuery
        Folder    = $LogLocation
        Component = "[$ComputerName]::[$ScriptName]"
        Filename  = [string]::Format("{0}-{1}.log", $RBInstance, $ComputerName)
        Log       = $true
    }
    $AverageShutdownTime = Start-CompPatchQuery @startCompPatchQuerySplat | Select-Object -ExpandProperty AverageDuration
    if ([string]::IsNullOrEmpty($AverageShutdownTime)) {
        Write-CMLogEntry -Value "Unable to find data for calculating an average runtime based on previous runs. Defaulting to 900 seconds" -Severity 2
        $AverageShutdownTime = 400
    }
    $ShutdownThreshold = $AverageShutdownTime * 1.5
    if ($ShutdownThreshold -lt 600) {
        Write-CMLogEntry "Found that the ShutdownThreshold would be under 10 minutes. Defaulting to 10 minutes" -Severity 2
        $ShutdownThreshold = 600
    }
    $ShutdownThresholdTimespan = New-TimeSpan -Seconds $ShutdownThreshold
    $ShutdownTimer = [System.Diagnostics.Stopwatch]::StartNew()
    # Outer loop - if this one 'times out' then we throw an error. This should trigger an email for intervention
    $newLoopActionSplat = @{
        ExitCondition   = { $script:Shutdown }
        IfTimeoutScript = { 
            Write-CMLogEntry -Value "$script:ComputerName was not able to be shut down after repeated forced attempts. Exiting and throwing an error" -Severity 3
            throw "$script:ComputerName was not able to be shut down after $([math]::Round($script:ShutdownTimer.Elapsed.TotalMinutes, 2)) minutes" 
        }
        ScriptBlock     = {
            # Inner loop 1 - if this one 'times out' (2 iterations) we should force a shutdown using powercli because the VM is taking an excessive time to shutdown based off previous runs averages
            $newLoopActionSplat = @{
                ExitCondition   = { $script:Shutdown }
                IfTimeoutScript = { 
                    Write-CMLogEntry -Value "$script:ComputerName was not able to be shut down within the timeout thresheld of $([math]::Round($script:ShutdownTimer.Elapsed.TotalMinutes, 2)) minutes. Will attempt a forced shutdown." -Severity 3
                    Stop-VM -VM $script:VM -Confirm:$false
                }  
                ScriptBlock     = {
                    #region tell the servers to shutdown
                    Write-CMLogEntry "Checking for VM with name $script:ComputerName"
                    $VM = Get-VM -Name $script:ComputerName -ErrorAction Stop
                    if (($VM | Measure-Object | Select-Object -ExpandProperty Count) -gt 1) {
                        Write-CMLogEntry "Identified more than one VM with name $script:ComputerName. Selecting VM based on CustomField containing SRM"
                        $VM = $VM | Where-Object { $_.CustomFields.Keys -match 'srm' }
                    }
                    Write-CMLogEntry "Identified [VM=$($VM.Name)] based off [ComputerName=$script:ComputerName]"
                    $AllTasks = Get-Task
                    if ($RunningTask = ($AllTasks | Where-Object { $_.ObjectId -eq $VM.Id -and $_.State -notmatch "Success|Error" })) {
                        Write-CMLogEntry "Waiting on VM Task $($RunningTask.Name)"
                        Update-DBServerStatus -LastStatus 'Waiting on VM Task'
                        Wait-Task -Task $RunningTask -ErrorAction Stop
                    }
                    if ($VM.PowerState -eq 'PoweredOff') {
                        Write-CMLogEntry "$script:ComputerName was verified powered off"
                        Update-DBServerStatus -LastStatus 'Verified Shut Down'
                        $script:Shutdown = $true
                        $script:ResultStatus = "Success"
                    }
                    else {
                        Update-DBServerStatus -LastStatus 'Shutting Down'
            
                        Write-CMLogEntry "Executing 'Stop-Computer' for $script:ComputerName"
                        try {
                            Stop-Computer -ComputerName $script:FQDN -Credential $RemotingCreds -Force -ErrorAction Stop
                        }
                        catch {
                            $Message = $PSItem.Exception.Message
                            if ($Message -notmatch 'A system shutdown is in progress') {
                                Write-CMLogEntry -Value "Failed to execute Stop-Computer for $script:ComputerName with message [$Message]" -Severity 2
                                if ($VM.ExtensionData.Guest.ToolsStatus -notin @('toolsNotRunning', 'toolsNotInstalled')) {
                                    Write-CMLogEntry "Validated that VMware Tools is running on the VM"
                                    try {
                                        Write-CMLogEntry "Shutting down $script:ComputerName using PowerCLI"
                                        Shutdown-VMGuest -VM $VM -Confirm:$false -ErrorAction Stop
                                    }
                                    catch {
                                        Write-CMLogEntry -Value "Failed to shutdown VM using Shutdown-VMGuest" -Severity 3
                                        throw "Unable to shutdown computer"
                                    }
            
                                    Write-CMLogEntry "Looping Get-VMGuest and checking State to determine if shutdown is happening"
                                    $newLoopActionSplat = @{
                                        ScriptBlock     = {
                                            $script:ShutdownStatus = Get-VMGuest -VM $script:VM | Select-Object -ExpandProperty State
                                        }
                                        ExitCondition   = { $script:ShutdownStatus -match "ShuttingDown|NotRunning" }
                                        IfTimeoutScript = {
                                            Write-CMLogEntry -Value "Failed to validate shutdown VM using Shutdown-VMGuest - [State=$script:ShutdownStatus] after $([math]::Round($script:ShutdownTimer.Elapsed.TotalMinutes, 2)) minutes" -Severity 3
                                        }
                                        IfSucceedScript = {
                                            Write-CMLogEntry -Value "Validated shutting down via Shutdown-VMGuest - [State=$script:ShutdownStatus] after $([math]::Round($script:ShutdownTimer.Elapsed.TotalMinutes, 2)) minutes"
                                        }
                                        LoopDelayType   = 'Seconds'
                                        LoopDelay       = 10
                                        LoopTimeoutType = 'Minutes'
                                        LoopTimeout     = 5
                                    }
                                    New-LoopAction @newLoopActionSplat
                                }
                                else {
                                    Write-CMLogEntry -Value "Failed to validate that VMware tools is running on the VM" -Severity 3
                                }
                            }
                        }
                        #endregion tell the servers to shutdown
            
                        #region verify that the server is powered off
                        # Inner loop 2 - if this one 'times out' we simply loop until we have exceeded our (average shutdown runtime * 1.5)
                        Write-CMLogEntry "Looping Get-VM and checking State to determine if VM is powered off - Will timeout after $([math]::Round($ShutdownThresholdTimespan.TotalMinutes, 2)) minutes per iteration."
                        $newLoopActionSplat = @{
                            ExitCondition   = { $VM.PowerState -notcontains "PoweredOn" }
                            IfTimeoutScript = {
                                Write-CMLogEntry "Failed to verify that the [Server=$script:ComputerName] was shut off after $([math]::Round($script:ShutdownTimer.Elapsed.TotalMinutes, 2)) minutes" -Severity 2
                                $script:ShutdownStatus = Get-VMGuest -VM $script:VM | Select-Object -ExpandProperty State
                            }
                            ScriptBlock     = {
                                $VM = Get-VM -Name $script:ComputerName -ErrorAction Stop
                                if (($VM | Measure-Object | Select-Object -ExpandProperty Count) -gt 1) {
                                    Write-CMLogEntry "Identified more than one VM with name $script:ComputerName. Selecting VM based on CustomField containing SRM"
                                    $VM = $VM | Where-Object { $_.CustomFields.Keys -match 'srm' }
                                }
                            }
                            LoopDelay       = 30
                            IfSucceedScript = {
                                $script:Shutdown = $true
                                $script:ShutdownStatus = Get-VMGuest -VM $script:VM | Select-Object -ExpandProperty State
                                Write-CMLogEntry "Verified that [Server=$script:ComputerName] was shut off after $([math]::Round($script:ShutdownTimer.Elapsed.TotalMinutes, 2)) minutes"
                                Update-DBServerStatus -LastStatus 'Verified Shut Down'
                                $script:ResultStatus = "Success"
                            }
                            LoopTimeoutType = 'Seconds'
                            LoopTimeout     = $ShutdownThreshold
                        }
                        New-LoopAction @newLoopActionSplat
                        #endregion verify that the server is powered off
                    }
                }
                Iterations      = 2
            }
            New-LoopAction @newLoopActionSplat        
        }
        Iterations      = 2
    }
    New-LoopAction @newLoopActionSplat
    #endregion shutdown server - will calculate average time to shutdown, monitor status and force as needed
}
catch {
    # Catch any errors thrown above here, setting the result status and recording the error message to return to the activity for data bus publishing
    $ResultStatus = "Failed"
    $ErrorMessage = $error[0].Exception.Message
    $LastStatus = "Failed: $global:CurrentAction"
    Update-DBServerStatus -LastStatus $LastStatus
    Write-CMLogEntry "Exception caught during action [$global:CurrentAction]: $ErrorMessage" -Severity 3
}
finally {
    # Always do whatever is in the finally block. In this case, adding some additional detail about the outcome to the trace log for return
    if ($ErrorMessage.Length -gt 0) {
        Write-CMLogEntry "Exiting script with result [$ResultStatus] and [ShutDownState=$script:ShutdownStatus] and error message [$ErrorMessage]" -Severity 3
    }
    else {
        Write-CMLogEntry "Exiting script with result [ResultStatus=$ResultStatus] and [ShutDownState=$script:ShutdownStatus]"
    }
    $ShutdownTimer.Reset()
}
# Record end of activity script process
Update-DBServerStatus -Status "Finished $ScriptName"
Update-DBServerStatus -Stage 'End' -Component $ScriptName
Write-CMLogEntry "Script finished"