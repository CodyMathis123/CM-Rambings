function Test-AGRole {
    param
    (
        [parameter(Mandatory = $true)]
        [string]$ComputerName,
        # Computer which we will query for Availability group information

        [parameter(Mandatory = $true)]
        [string]$DryRun,
        # skips patching check so that we can perform a dry run of the drain an resume

        [parameter(Mandatory = $true)]
        [string]$Grouping,
        # The grouping of the computer

        [parameter(Mandatory = $true)]
        [string]$RBInstance,
        # The rbinstance for this grouping of servers

        [parameter(Mandatory = $true)]
        [string]$SQLServer,
        # Database server for staging information during the patching process

        [parameter(Mandatory = $true)]
        [string]$OrchStagingDB,
        # Database for staging information during the patching process

        [parameter(Mandatory = $true)]
        [string]$LogLocation
        # UNC path to store log files in
    )

    #region import modules
    Import-Module -Name ComplexPatching
    #endregion import modules

    #-----------------------------------------------------------------------

    ## Initialize result and trace variables
    # $ResultStatus provides basic success/failed indicator
    # $ErrorMessage captures any error text generated by script
    # $Trace is used to record a running log of actions
    [bool]$DryRun = ConvertTo-Boolean $DryRun
    $ResultStatus = "Success"
    $ErrorMessage = ""
    $global:CurrentAction = ""
    $ScriptName = $((Split-Path $PSCommandPath -Leaf) -Replace '.ps1', $null)

    #region set our defaults for the our functions
    #region Write-CMLogEntry defaults
    $Bias = Get-WmiObject -Class Win32_TimeZone | Select-Object -ExpandProperty Bias
    $PSDefaultParameterValues.Add("Write-CMLogEntry:Bias", $Bias)
    $PSDefaultParameterValues.Add("Write-CMLogEntry:FileName", [string]::Format("{0}-{1}.log", $RBInstance, $ComputerName))
    $PSDefaultParameterValues.Add("Write-CMLogEntry:Folder", $LogLocation)
    $PSDefaultParameterValues.Add("Write-CMLogEntry:Component", "[$ComputerName]::[$ScriptName]")
    #endregion Write-CMLogEntry defaults

    #region Update-DBServerStatus defaults
    $PSDefaultParameterValues.Add("Update-DBServerStatus:ComputerName", $ComputerName)
    $PSDefaultParameterValues.Add("Update-DBServerStatus:RBInstance", $RBInstance)
    $PSDefaultParameterValues.Add("Update-DBServerStatus:SQLServer", $SQLServer)
    $PSDefaultParameterValues.Add("Update-DBServerStatus:Database", $OrchStagingDB)
    #endregion Update-DBServerStatus defaults

    #region Start-CompPatchQuery defaults
    $PSDefaultParameterValues.Add("Start-CompPatchQuery:SQLServer", $SQLServer)
    $PSDefaultParameterValues.Add("Start-CompPatchQuery:Database", $OrchStagingDB)
    #endregion Start-CompPatchQuery defaults
    #endregion set our defaults for our functions

    Write-CMLogEntry "Runbook activity script started - [Running On = $env:ComputerName]"
    Update-DBServerStatus -Status "Started $ScriptName"
    Update-DBServerStatus -Stage 'Start' -Component $ScriptName -DryRun $DryRun

    try {
        #region query all HA instances
        Write-CMLogEntry "Veryifying that no partner servers for [Grouping=$Grouping] [PatchStrategy = 'SQL-HA'] had issues during their run"
        Update-DBServerStatus -LastStatus "Validating AG partners"
        $PartnerServer_StatusQuery = [string]::Format("SELECT * FROM [dbo].[ServerStatus] WHERE (Status LIKE '%Fail%' OR LastStatus LIKE '%Fail%') AND PatchStrategy = 'SQL-HA' AND Grouping = '{0}'", $Grouping)
        $PartnerServer_Status = Start-CompPatchQuery -Query $PartnerServer_StatusQuery
        if ($null -ne $PartnerServer_Status) {
            foreach ($Server in $PartnerServer_Status) {
                Write-CMLogEntry "Failure identified - [ComputerName=$($Server.ServerName)] [Status=$($Server.Status)] [LastStatus=$($Server.LastStatus)]" -Severity 3
            }
            Write-CMLogEntry "Identified partner servers in a failure state. Patching will stop." -Severity 3
            throw "Identified partner servers in a failure state. Patching will stop."
        }
        Write-CMLogEntry "Querying $OrchStagingDB for all servers with [Grouping=$Grouping] [PatchStrategy = 'SQL-HA']"
        $HASQLInfoQuery = [string]::Format("SELECT * FROM [dbo].[ServerStatus] WHERE PatchStrategy = 'SQL-HA' AND Grouping = '{0}'", $Grouping)
        $HASQLInfo = Start-CompPatchQuery -Query $HASQLInfoQuery
        Write-CMLogEntry "Querying any server that is NOT the server we are patching from each availability group to get group info"
    
        $ServerToQuery = Get-Random -InputObject ($HASQLInfo.where{ $_.ServerName -ne $ComputerName }).ServerName
        $FQDN = Get-FQDNFromDB -ComputerName $ServerToQuery -SQLServer $SQLServer -Database $OrchStagingDB
        try {
            $CurrentHAInfo = Invoke-SQLcmd2 -ServerInstance $FQDN -Query "SELECT replica_server_name,CASE
        WHEN replica_server_name=ag.primary_replica THEN 'PRIMARY' ELSE 'SECONDARY'END [Status]
        ,synchronization_health_desc,g.name,failover_mode_desc,secondary_role_allow_connections_desc ReadableSec
        FROM sys.availability_replicas r INNER JOIN [sys].[availability_groups] g
        ON r.group_id=g.group_id LEFT JOIN [master].[sys].[dm_hadr_availability_group_states] ag
        ON r.group_id=ag.group_id
        WHERE failover_mode_desc = 'AUTOMATIC'
        ORDER BY 2"
        }
        catch {
            Write-CMLogEntry -Value "Unable to query server that would be primary going forward, stopping all action" -Severity 3
            Update-DBServerStatus -LastStatus "Failed to query partner server"
            throw "Unable to query server that would be primary going forward, stopping all action"
        }

        if ($null -ne $CurrentHAInfo) {
            Write-CMLogEntry "Validating that all availability groups are healthy"
            foreach ($Node in $CurrentHAInfo) {
                Write-CMLogEntry "NODE::[ServerName=$($Node.'replica_server_name')] [Status=$($Node.Status)] [AvailabilityGroupName=$($Node.name)] [Health=$($Node.'synchronization_health_desc')]"
            }
            #endregion query all HA instances

            #region validate that all AG are healthy
            Update-DBServerStatus -LastStatus "Validating AG health"
            New-LoopAction -LoopTimeout 5 -LoopTimeoutType Minutes -LoopDelay 30 -LoopDelayType Seconds -ScriptBlock {
                $Healthy = $false

                $ServerToQuery = Get-Random -InputObject ($script:HASQLInfo.where{ $_.ServerName -ne $script:ComputerName }).ServerName
                $FQDN = Get-FQDNFromDB -ComputerName $ServerToQuery -SQLServer $SQLServer -Database $OrchStagingDB
                try {
                    $CurrentHAInfo = Invoke-SQLcmd2 -ServerInstance $FQDN -Query "SELECT replica_server_name,CASE
                WHEN replica_server_name=ag.primary_replica THEN 'PRIMARY' ELSE 'SECONDARY'END [Status]
                ,synchronization_health_desc,g.name,failover_mode_desc,secondary_role_allow_connections_desc ReadableSec
                FROM sys.availability_replicas r INNER JOIN [sys].[availability_groups] g
                ON r.group_id=g.group_id LEFT JOIN [master].[sys].[dm_hadr_availability_group_states] ag
                ON r.group_id=ag.group_id
                WHERE failover_mode_desc = 'AUTOMATIC'
                ORDER BY 2"
                }
                catch {
                    Write-CMLogEntry -Value "Unable to query server that would be primary going forward, stopping all action" -Severity 3
                    throw "Unable to query server that would be primary going forward, stopping all action"
                }

                $NonHealthy = $CurrentHAInfo | Where-Object { $_.'synchronization_health_desc' -ne 'HEALTHY' }
                if ($null -eq $NonHealthy) {
                    $Healthy = $true
                }
            } -ExitCondition { $Healthy } -IfTimeoutScript {
                Write-CMLogEntry -Value "Failed to validate that all availability groups are 'HEALTHY' after 5 minutes" -Severity 3
                throw "Failed to validate that all availability groups are 'HEALTHY' after 5 minutes"
            } -IfSucceedScript {
                Update-DBServerStatus -LastStatus "AG health validated"
                Write-CMLogEntry "Validated that all availability groups are 'HEALTHY'"
            }
            #endregion validate that all AG are healthy

            Write-CMLogEntry "will failover all availability groups that $ComputerName participates in as PRIMARY"
            $GroupsToFailover = $CurrentHAInfo | Where-Object { $_.'replica_server_name' -eq $ComputerName -and $_.Status -eq 'PRIMARY' } | Select-Object -ExpandProperty name
            if ($null -ne $GroupsToFailover) {
                #region failover as needed
                Write-CMLogEntry "At least one availability group requires failover"
                Update-DBServerStatus -LastStatus "Beginniner failover"
                foreach ($SQLHAgroup in $GroupsToFailover) {
                    $SecondaryServer = $CurrentHAInfo | Where-Object { $_.Name -eq $SQLHAgroup -and $_.Status -eq 'SECONDARY' } | Select-Object -ExpandProperty 'replica_server_name'
                    Write-CMLogEntry "Performing failover - executing [ALTER AVAILABILITY GROUP [$SQLHAgroup] FAILOVER;] against $SecondaryServer"
                    Invoke-SQLcmd2 -ServerInstance $SecondaryServer -Query "ALTER AVAILABILITY GROUP [$SQLHAgroup] FAILOVER;"
                }
                #endregion failover as needed

                #region query all HA instances
                $HASQLInfoQuery = [string]::Format("SELECT * FROM [dbo].[ServerStatus] WHERE PatchStrategy = 'SQL-HA' AND Grouping = '{0}'", $Grouping)
                $HASQLInfo = Start-CompPatchQuery -Query $HASQLInfoQuery        
                $Grouping = $HASQLInfo | Select-Object -ExpandProperty Grouping
                $ServerToQuery = Get-Random -InputObject ($HASQLInfo).ServerName
                $FQDN = Get-FQDNFromDB -ComputerName $ServerToQuery -SQLServer $SQLServer -Database $OrchStagingDB
                $CurrentHAInfo = Invoke-SQLcmd2 -ServerInstance $FQDN -Query "SELECT replica_server_name,CASE
            WHEN replica_server_name=ag.primary_replica THEN 'PRIMARY' ELSE 'SECONDARY'END [Status]
            ,synchronization_health_desc,g.name,failover_mode_desc,secondary_role_allow_connections_desc ReadableSec
            FROM sys.availability_replicas r INNER JOIN [sys].[availability_groups] g
            ON r.group_id=g.group_id LEFT JOIN [master].[sys].[dm_hadr_availability_group_states] ag
            ON r.group_id=ag.group_id
            WHERE failover_mode_desc = 'AUTOMATIC'
            ORDER BY 2"
                #endregion query all HA instances

                $GroupsToFailover = $CurrentHAInfo | Where-Object { $_.'replica_server_name' -eq $ComputerName -and $_.Status -eq 'PRIMARY' } | Select-Object -ExpandProperty name
                if ($null -ne $GroupsToFailover) {
                    Write-CMLogEntry -Value "Failover still needed on at least one SQL HA Instance" -Severity 3
                    throw "Failover still needed on at least one SQL HA Instance"
                }
                else {
                    Write-CMLogEntry "Failover complete for all availability groups"
                    Update-DBServerStatus -LastStatus "Failover complete"
                    $ResultStatus = 'Success'
                }
            }
            else {
                Write-CMLogEntry "Determined that all availability groups are in a desired state, no failover needed"
                $ResultStatus = 'Success'
            }
        }
        else {
            Write-CMLogEntry "Failed to identify servers and their respective roles" -Severity 3
            throw 'Failed to identify servers and their respective roles'
        }
    }
    catch {
        # Catch any errors thrown above here, setting the result status and recording the error message to return to the activity for data bus publishing
        $ResultStatus = "Failed"
        $ErrorMessage = $error[0].Exception.Message
        $LastStatus = "Failed: $global:CurrentAction"
        Update-DBServerStatus -LastStatus $LastStatus
        Write-CMLogEntry "Exception caught during action [$global:CurrentAction]: $ErrorMessage" -Severity 3
    }
    finally {
        # Always do whatever is in the finally block. In this case, adding some additional detail about the outcome to the trace log for return
        if ($ErrorMessage.Length -gt 0) {
            Write-CMLogEntry "Exiting script with result [$ResultStatus] and error message [$ErrorMessage]" -Severity 3
        }
        else {
            Write-CMLogEntry "Exiting script with result [$ResultStatus]"
        }
    }
    # Record end of activity script process
    Update-DBServerStatus -Status "Finished $ScriptName"
    Update-DBServerStatus -Stage 'End' -Component $ScriptName
    Write-CMLogEntry "Script finished"
}