param
(
    [parameter(Mandatory = $true)]
    [string]$ComputerName,
    # Provides the computer name to check services on

    [parameter(Mandatory = $true)]
    [string]$DryRun,
    # skips patching check so that we can perform a dry run of the drain an resume

    [parameter(Mandatory = $true)]
    [int32]$RBInstance,
    # RBInstance which represents the Runbook Process ID for this runbook workflow

    [parameter(Mandatory = $true)]
    [string]$SQLServer,
    # Database server for staging information during the patching process

    [parameter(Mandatory = $true)]
    [string]$OrchStagingDB,
    # Database for staging information during the patching process

    [parameter(Mandatory = $true)]
    [string]$SolarwindsURI,
    # URI for Solarwinds which will allow us to mute alerts for a period of time

    [parameter(Mandatory = $true)]
    [string]$LogLocation
    # UNC path to store log files in
)

#region import modules
Import-Module -Name ComplexPatching
#endregion import modules

#-----------------------------------------------------------------------

## Initialize result and trace variables
# $ResultStatus provides basic success/failed indicator
# $ErrorMessage captures any error text generated by script
# $Trace is used to record a running log of actions
[bool]$DryRun = ConvertTo-Boolean $DryRun
$Muted = $false
$ErrorMessage = ""
$global:CurrentAction = ""
$ScriptName = $((Split-Path $PSCommandPath -Leaf) -Replace '.ps1', $null)

#region set our defaults for the our functions
#region Write-CMLogEntry defaults
$Bias = Get-WmiObject -Class Win32_TimeZone | Select-Object -ExpandProperty Bias
$PSDefaultParameterValues.Add("Write-CMLogEntry:Bias", $Bias)
$PSDefaultParameterValues.Add("Write-CMLogEntry:FileName", [string]::Format("{0}-{1}.log", $RBInstance, $ComputerName))
$PSDefaultParameterValues.Add("Write-CMLogEntry:Folder", $LogLocation)
$PSDefaultParameterValues.Add("Write-CMLogEntry:Component", "[$ComputerName]::[$ScriptName]")
#endregion Write-CMLogEntry defaults

#region Update-DBServerStatus defaults
$PSDefaultParameterValues.Add("Update-DBServerStatus:ComputerName", $ComputerName)
$PSDefaultParameterValues.Add("Update-DBServerStatus:RBInstance", $RBInstance)
$PSDefaultParameterValues.Add("Update-DBServerStatus:SQLServer", $SQLServer)
$PSDefaultParameterValues.Add("Update-DBServerStatus:Database", $OrchStagingDB)
#endregion Update-DBServerStatus defaults

#region Start-CompPatchQuery defaults
$PSDefaultParameterValues.Add("Start-CompPatchQuery:SQLServer", $SQLServer)
$PSDefaultParameterValues.Add("Start-CompPatchQuery:Database", $OrchStagingDB)
#endregion Start-CompPatchQuery defaults
#endregion set our defaults for our functions



Write-CMLogEntry "Runbook activity script started - [Running On = $env:ComputerName]"
Update-DBServerStatus -Status "Started $ScriptName"
Update-DBServerStatus -Stage 'Start' -Component $ScriptName -DryRun $DryRun

try {
    #region modules
    Import-Module -Name SwisPowerShell -ErrorAction Stop
    Write-CMLogEntry "SwisPowerShell module imported"
    #endregion modules

    #region create credential objects
    Write-CMLogEntry "Creating necessary credential objects"
    $NMSCreds = Get-StoredCredential -Purpose Solarwinds -SQLServer $SQLServer -Database $OrchStagingDB
    #endregion create credential objects

    #region connect to Solarwinds
    Write-CMLogEntry "Connecting to Solarwinds at $SolarwindsURI"
    $SWIS = Connect-SWIS -Hostname $SolarwindsURI -Credential $NMSCreds -ErrorAction Stop
    Write-CMLogEntry "Connected to Solarwinds at $SolarwindsURI"
    #endregion connect to Solarwinds

    #region query current status of alerts
    Write-CMLogEntry "Querying Solarwinds for $ComputerName"
    $Node = Get-SwisData -SwisConnection $SWIS -Query @"
SELECT Caption, IP_Address, Uri AS [EntityUri]
FROM Orion.Nodes
WHERE  Caption = '$ComputerName'
    AND Vendor = 'Windows'
    AND ObjectSubType IN ( 'Agent', 'WMI' )
ORDER BY Caption
"@ -ErrorAction Stop
    if ($Node.Caption -eq $ComputerName) {
        Write-CMLogEntry "Identified $($Node.Caption) in Solarwinds"

        Write-CMLogEntry "Querying for suppression of alerts for $($Node.Caption) in Solarwinds"
        $SuppressionQuery = @"
        SELECT EntityUri, SuppressFrom, SuppressUntil
        FROM Orion.AlertSuppression
        WHERE EntityUri = '$( $Node.EntityUri )'
"@
        $Suppression = Get-SwisData -SwisConnection $SWIS -Query $SuppressionQuery -ErrorAction Stop
        $Now = Get-Date
        if ($Suppression) {
            if ($Now -gt $Suppression.SuppressFrom.ToLocalTime() -and $Now -lt $Suppression.SuppressUntil.ToLocalTime()) {
                $Muted = $true
            }
        }
        Write-CMLogEntry "$ComputerName identified in Solarwinds with status [Muted=$Muted]"
        #endregion query current status of alerts

        #region mute alerts for the server for 3 hours
        if (-not $Muted) {
            Update-DBServerStatus -LastStatus "Suppressing Alerts"
            $Delay = Get-Random -Minimum 10 -Maximum 30
            New-LoopAction -LoopTimeout 5 -LoopTimeoutType Minutes -LoopDelay $Delay -LoopDelayType Seconds -ScriptBlock {
                $Success = $false
                $SuppressFrom = (Get-date).ToLocalTime()
                $SuppressUntil = $SuppressFrom.AddHours('3').ToLocalTime()
                try {
                    Invoke-SwisVerb -SwisConnection $script:SWIS -EntityName Orion.AlertSuppression -Verb SuppressAlerts -Arguments @( @($script:Node.EntityURI), $SuppressFrom, $SuppressUntil) -ErrorAction SilentlyContinue
                    Write-CMLogEntry "Invoked alert muting, now querying for suppression of alerts for $($Node.Caption) in Solarwinds to confirm it worked."
                    $Suppression = Get-SwisData -SwisConnection $SWIS -Query $script:SuppressionQuery -ErrorAction SilentlyContinue
                    $Now = Get-Date
                    if ($Suppression) {
                        if ($Now -gt $Suppression.SuppressFrom.ToLocalTime() -and $Now -lt $Suppression.SuppressUntil.ToLocalTime()) {
                            Write-CMLogEntry "$script:ComputerName alerts suppressed from $SuppressFrom until $SuppressUntil"
                            $Success = $true
                        }
                    }
                }
                catch {
                    $Success = $false
                }
            } -ExitCondition { $Success } -IfTimeoutScript { throw "Failed to suppress alerts for $ComputerName" }
        }
    }
    else {
        Write-CMLogEntry "Did not find $ComputerName in Solarwinds"
    }

    $ResultStatus = 'Success'
    #endregion mute alerts for the server for 3 hours
}
catch {
    # Catch any errors thrown above here, setting the result status and recording the error message to return to the activity for data bus publishing
    $ResultStatus = "Failed"
    $ErrorMessage = $error[0].Exception.Message
    Write-CMLogEntry "Exception caught during action [$global:CurrentAction]: $ErrorMessage" -Severity 3
    Update-DBServerStatus -LastStatus 'Alert Suppression Failed'
}
finally {
    # Always do whatever is in the finally block. In this case, adding some additional detail about the outcome to the trace log for return
    if ($ErrorMessage.Length -gt 0) {
        $ResultStatus = 'Failed'
        Write-CMLogEntry "Exiting script with result [$ResultStatus] and error message [$ErrorMessage]" -Severity 3
    }
    else {
        Write-CMLogEntry "Exiting script with result [$ResultStatus]"
        Update-DBServerStatus -LastStatus 'Alerts Suppressed'
    }
}
# Record end of activity script process
Update-DBServerStatus -Status "Finished $ScriptName"
Update-DBServerStatus -Stage 'End' -Component $ScriptName
Write-CMLogEntry "Script finished"