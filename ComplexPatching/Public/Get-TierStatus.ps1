param
(
    [parameter(Mandatory = $true)]
    [string]$ComputerName,
    # Provides the computer name which we want to know the tier-status of in relation to other servers in the same tier and in the same grouping

    [parameter(Mandatory = $true)]
    [string]$DryRun,
    # skips patching check so that we can perform a dry run of the drain an resume

    [parameter(Mandatory = $true)]
    [string]$ServerTier,
    # Provides the tier of the server

    [parameter(Mandatory = $true)]
    [string]$Grouping,
    # Provides the grouping of the server

    [parameter(Mandatory = $true)]
    [string]$Status,
    # Provides the status that you are looking for in SQL for the matching servers in the grouping

    [parameter(Mandatory = $true)]
    [ValidateSet('Drain', 'Resume')]
    [string]$Purpose,
    # Provides the purpose of the script, either drain or resume

    [parameter(Mandatory = $true)]
    [int32]$RBInstance,
    # RBInstance which represents the Runbook Process ID for this runbook workflow

    [parameter(Mandatory = $true)]
    [string]$SQLServer,
    # Database server for staging information during the patching process

    [parameter(Mandatory = $true)]
    [string]$OrchStagingDB,
    # Database for staging information during the patching process

    [parameter(Mandatory = $true)]
    [string]$LogLocation
    # UNC path to store log files in
)

#region import modules
Import-Module -Name ComplexPatching
#endregion import modules

#-----------------------------------------------------------------------

## Initialize result and trace variables
# $ResultStatus provides basic success/failed indicator
# $ErrorMessage captures any error text generated by script
# $Trace is used to record a running log of actions
[bool]$DryRun = ConvertTo-Boolean $DryRun
$ResultStatus = ""
$ErrorMessage = ""
$global:CurrentAction = ""
$ScriptName = $((Split-Path $PSCommandPath -Leaf) -Replace '.ps1', $null)

#region set our defaults for the our functions
#region Write-CMLogEntry defaults
$Bias = Get-WmiObject -Class Win32_TimeZone | Select-Object -ExpandProperty Bias
$PSDefaultParameterValues.Add("Write-CMLogEntry:Bias", $Bias)
$PSDefaultParameterValues.Add("Write-CMLogEntry:FileName", [string]::Format("{0}-{1}.log", $RBInstance, $ComputerName))
$PSDefaultParameterValues.Add("Write-CMLogEntry:Folder", $LogLocation)
$PSDefaultParameterValues.Add("Write-CMLogEntry:Component", "[$ComputerName]::[$ScriptName]")
#endregion Write-CMLogEntry defaults

#region Get-PendingSCMReboot defaults
$PSDefaultParameterValues.Add("Get-PendingSCCMReboot:Credential", $RemotingCreds)
#endregion Get-PendingSCMReboot defaults

#region Update-DBServerStatus defaults
$PSDefaultParameterValues.Add("Update-DBServerStatus:ComputerName", $ComputerName)
$PSDefaultParameterValues.Add("Update-DBServerStatus:RBInstance", $RBInstance)
$PSDefaultParameterValues.Add("Update-DBServerStatus:SQLServer", $SQLServer)
$PSDefaultParameterValues.Add("Update-DBServerStatus:Database", $OrchStagingDB)
#endregion Update-DBServerStatus defaults

#region Start-CompPatchQuery defaults
$PSDefaultParameterValues.Add("Start-CompPatchQuery:SQLServer", $SQLServer)
$PSDefaultParameterValues.Add("Start-CompPatchQuery:Database", $OrchStagingDB)
#endregion Start-CompPatchQuery defaults
#endregion set our defaults for our functions


Write-CMLogEntry "Runbook activity script started - [Running On = $env:ComputerName]"
Update-DBServerStatus -Status "Started $ScriptName"
Update-DBServerStatus -Stage 'Start' -Component "$ScriptName-$Purpose" -DryRun $DryRun

try {
    #region create credential objects
    $RemotingCreds = Get-StoredCredential -ComputerName $ComputerName -SQLServer $SQLServer -Database $OrchStagingDB -SQLServer $SQLServer -Database $OrchStagingDB
    #endregion create credential objects

    $FQDN = Get-FQDNFromDB -ComputerName $ComputerName -SQLServer $SQLServer -Database $OrchStagingDB

    #region gather tier info
    $TimeOut = $false
    $Failures = $false
    $IsLowest = $false
    $IsHighest = $false
    $ExitLoop = $false
    $TiersQuery = [string]::Format("Select Tier from [dbo].[ServerStatus] WHERE Grouping = '{0}'", $Grouping)
    $Tiers = Start-CompPatchQuery -Query $TiersQuery | Select-Object -ExpandProperty Tier -Unique
    $TotalTiers = $Tiers | Measure-Object -Maximum | Select-Object -ExpandProperty Maximum
    $LowestTier = $Tiers | Measure-Object -Minimum | Select-Object -ExpandProperty Minimum
    Write-CMLogEntry -Value "Beginning $script:ScriptName [ServerName=$ComputerName] [Purpose=$Purpose] [DesiredStatus=$Status] [Grouping=$Grouping] [ServerTier=$ServerTier] [TotalTiers=$TotalTiers]"
    switch ($ServerTier) {
        ( { $ServerTier -eq $LowestTier }) {
            $IsLowest = $true
            Write-CMLogEntry -Value "$ComputerName is in the lowest tier"
        }
        ( { $ServerTier -eq $TotalTiers }) {
            $IsHighest = $true
            Write-CMLogEntry -Value "$ComputerName is in the highest tier"
        }
    }
    #endregion gather tier info

    #region loop to check tier statuses until conditions are met
    switch ($Purpose) {
        'Drain' {
            $newLoopActionSplat = @{
                ScriptBlock     = {
                    if ($script:IsHighest) {
                        Write-CMLogEntry "Exiting Loop: Server is in the highest tier"
                        $script:ResultStatus = 'Success'
                        $script:ExitLoop = $true
                    }
                    elseif ($script:IsLowest) {
                        $ServersByGroupAndTierQuery = [string]::Format("SELECT * FROM [dbo].[ServerStatus] WHERE Grouping = '{0}' AND Tier != '{1}'", $script:Grouping, $script:ServerTier)
                        $ServersByGroupAndTier = Start-CompPatchQuery -Query $ServersByGroupAndTierQuery
                        $ServersByStatus = $ServersByGroupAndTier | Where-Object { $_.Status -match "Fail|Error|$script:Status" -or $_.LastStatus -match "Fail|Error|$script:Status" }
                        [bool]$script:Failures = [bool]($ServersByStatus | Where-Object { $_.Status -match "Fail|Error" -or $_.LastStatus -match "Fail|Error" })
                        $Need = $ServersByGroupAndTier | Measure-Object | Select-Object -ExpandProperty Count
                        $Have = $ServersByStatus | Measure-Object | Select-Object -ExpandProperty Count
                        if ($Have -eq $Need) {
                            $script:ResultStatus = 'Success'
                            Write-CMLogEntry "Exiting loop: All servers in a desired state - [ResultStatus=$script:ResultStatus] [Errors=$script:Failures]"
                            $script:ExitLoop = $true
                        }
                        else {
                            if ($LastRun -ne $Have) {
                                Update-DBServerStatus -Status "$script:Purpose - Waiting on $($Need - $Have) servers"
                                Write-CMLogEntry "There are $Have servers in a desired state - Waiting on $($Need - $Have) servers [Errors=$script:Failures]"
                            }
                        }
                        $LastRun = $Have
                    }
                    else {
                        $ServersByGroupAndTierQuery = [string]::Format("SELECT * FROM [dbo].[ServerStatus] WHERE Grouping = '{0}' AND Tier > '{1}'", $script:Grouping, $script:ServerTier)
                        $ServersByGroupAndTier = Start-CompPatchQuery -Query $ServersByGroupAndTierQuery
                        $ServersByStatus = $ServersByGroupAndTier | Where-Object { $_.Status -match "Fail|Error|$script:Status" -or $_.LastStatus -match "Fail|Error|$script:Status" }
                        [bool]$script:Failures = [bool]($ServersByStatus | Where-Object { $_.Status -match "Fail|Error" -or $_.LastStatus -match "Fail|Error" })
                        $Need = $ServersByGroupAndTier | Measure-Object | Select-Object -ExpandProperty Count
                        $Have = $ServersByStatus | Measure-Object | Select-Object -ExpandProperty Count
                        if ($Have -eq $Need) {
                            $script:ResultStatus = 'Success'
                            Write-CMLogEntry "Exiting loop: All servers in a desired state - [ResultStatus=$script:ResultStatus] [Errors=$script:Failures]"
                            $script:ExitLoop = $true
                        }
                        else {
                            if ($LastRun -ne $Have) {
                                Update-DBServerStatus -Status "$script:Purpose - Waiting on $($Need - $Have) servers"
                                Write-CMLogEntry "There are $Have servers in a desired state - Waiting on $($Need - $Have) servers [Errors=$script:Failures]"
                            }
                        }
                        $LastRun = $Have
                    }
                }
                IfTimeoutScript = {
                    $script:TimeOut = $true
                }
                LoopDelay       = 15
                LoopTimeoutType = 'Minutes'
                LoopTimeout     = 120
                ExitCondition   = { $script:ExitLoop }
            }
            New-LoopAction @newLoopActionSplat
        }
        'Resume' {
            $newLoopActionSplat = @{
                ScriptBlock     = {
                    if ($script:IsLowest) {
                        Write-CMLogEntry "Exiting Loop: Server is in the lowest tier"
                        $script:ResultStatus = 'Success'
                        $script:ExitLoop = $true
                    }
                    else {
                        $ServersByGroupAndTierQuery = [string]::Format("SELECT * FROM [dbo].[ServerStatus] WHERE Grouping = '{0}' AND Tier < '{1}'", $script:Grouping, $script:ServerTier)
                        $ServersByGroupAndTier = Start-CompPatchQuery -Query $ServersByGroupAndTierQuery
                        $ServersByStatus = $ServersByGroupAndTier | Where-Object { $_.Status -match "Fail|Error|$script:Status" -or $_.LastStatus -match "Fail|Error|$script:Status" }
                        [bool]$script:Failures = [bool]($ServersByStatus | Where-Object { $_.Status -match "Fail|Error" -or $_.LastStatus -match "Fail|Error" })
                        $Need = $ServersByGroupAndTier | Measure-Object | Select-Object -ExpandProperty Count
                        $Have = $ServersByStatus | Measure-Object | Select-Object -ExpandProperty Count
                        if ($Have -eq $Need) {
                            $script:ResultStatus = 'Success'
                            Write-CMLogEntry "Exiting loop: All servers in a desired state - [ResultStatus=$script:ResultStatus] [Errors=$script:Failures]"
                            $script:ExitLoop = $true
                        }
                        else {
                            if ($LastRun -ne $Have) {
                                Update-DBServerStatus -Status "$script:Purpose - Waiting on $($Need - $Have) servers"
                                Write-CMLogEntry "There are $Have servers in a desired state - Waiting on $($Need - $Have) servers [Errors=$script:Failures]"
                            }
                        }
                        $LastRun = $Have
                    }
                }
                IfTimeoutScript = {
                    $script:TimeOut = $true
                }
                LoopDelay       = 15
                LoopTimeoutType = 'Minutes'
                LoopTimeout     = 120
                ExitCondition   = { $script:ExitLoop }
            }
            New-LoopAction @newLoopActionSplat
        }
    }
    #endregion loop to check tier statuses until conditions are met

    #region check for pending reboot from SCCM
    if ($Purpose -eq 'Drain') {
        $PendingReboot = Get-PendingSCCMReboot -ComputerName $FQDN
        Write-CMLogEntry "Pending reboot status [PendingReboot=$PendingReboot] [ServerName=$FQDN]"
    }
    #endregion check for pending reboot from SCCM

}
catch {
    # Catch any errors thrown above here, setting the result status and recording the error message to return to the activity for data bus publishing
    $ResultStatus = "Failed"
    $ErrorMessage = $error[0].Exception.Message
    Write-CMLogEntry "Exception caught during action [$global:CurrentAction]: $ErrorMessage"
}
finally {
    # Always do whatever is in the finally block. In this case, adding some additional detail about the outcome to the trace log for return
    if ($ErrorMessage.Length -gt 0) {
        Write-CMLogEntry "Exiting script with result [$ResultStatus] and error message [$ErrorMessage]" -Severity 3
    }
    else {
        Write-CMLogEntry "Exiting script with [ResultStatus=$ResultStatus] [Failures=$Failures] [TimeOut=$TimeOut]"
    }
}
# Record end of activity script process
Update-DBServerStatus -Status "Finished $ScriptName"
Update-DBServerStatus -Stage 'End' -Component "$ScriptName-$Purpose"
Write-CMLogEntry "Script finished"