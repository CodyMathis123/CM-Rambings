param
(
    [parameter(Mandatory = $true)]
    [string]$ComputerName,
    # Provides the computer name to start

    [parameter(Mandatory = $true)]
    [string]$DryRun,
    # skips patching check so that we can perform a dry run of the drain an resume

    [parameter(Mandatory = $true)]
    [int32]$RBInstance,
    # RBInstance which represents the Runbook Process ID for this runbook workflow

    [parameter(Mandatory = $true)]
    [string]$SQLServer,
    # Database server for staging information during the patching process

    [parameter(Mandatory = $true)]
    [string]$OrchStagingDB,
    # Database for staging information during the patching process

    [parameter(Mandatory = $true)]
    [array]$VIServers,
    # List of semicolon separated VIservers for connecting to vCenter

    [parameter(Mandatory = $true)]
    [string]$LogLocation
    # UNC path to store log files in
)

#region import modules
Import-Module -Name ComplexPatching
#endregion import modules

#-----------------------------------------------------------------------

## Initialize result and trace variables
# $ResultStatus provides basic success/failed indicator
# $ErrorMessage captures any error text generated by script
# $Trace is used to record a running log of actions
[bool]$DryRun = ConvertTo-Boolean $DryRun
$ResultStatus = ""
$ErrorMessage = ""
$global:CurrentAction = ""
$ScriptName = $((Split-Path $PSCommandPath -Leaf) -Replace '.ps1', $null)

#region set our defaults for the our functions
#region Write-CMLogEntry defaults
$Bias = Get-WmiObject -Class Win32_TimeZone | Select-Object -ExpandProperty Bias
$PSDefaultParameterValues.Add("Write-CMLogEntry:Bias", $Bias)
$PSDefaultParameterValues.Add("Write-CMLogEntry:FileName", [string]::Format("{0}-{1}.log", $RBInstance, $ComputerName))
$PSDefaultParameterValues.Add("Write-CMLogEntry:Folder", $LogLocation)
$PSDefaultParameterValues.Add("Write-CMLogEntry:Component", "[$ComputerName]::[$ScriptName]")
#endregion Write-CMLogEntry defaults

#region Update-DBServerStatus defaults
$PSDefaultParameterValues.Add("Update-DBServerStatus:ComputerName", $ComputerName)
$PSDefaultParameterValues.Add("Update-DBServerStatus:RBInstance", $RBInstance)
$PSDefaultParameterValues.Add("Update-DBServerStatus:SQLServer", $SQLServer)
$PSDefaultParameterValues.Add("Update-DBServerStatus:Database", $OrchStagingDB)
#endregion Update-DBServerStatus defaults

#region Start-CompPatchQuery defaults
$PSDefaultParameterValues.Add("Start-CompPatchQuery:SQLServer", $SQLServer)
$PSDefaultParameterValues.Add("Start-CompPatchQuery:Database", $OrchStagingDB)
#endregion Start-CompPatchQuery defaults
#endregion set our defaults for our functions

Write-CMLogEntry "Runbook activity script started - [Running On = $env:ComputerName]"
Update-DBServerStatus -Status "Started $ScriptName"
Update-DBServerStatus -Stage 'Start' -Component $ScriptName -DryRun $DryRun

try {
    #region modules
    if (!(Get-Module -Name 'vmware.powercli')) {
        Write-CMLogEntry "Import vmware.powercli module "
        Import-Module -Name 'vmware.powercli' -ErrorAction SilentlyContinue
    }
    #endregion modules

    #region connect to vmware
    Write-CMLogEntry "Connecting to VIServer $VIServers"
    Connect-Vcenter -Servers $VIServers
    #endregion connect to vmware

    $FQDN = Get-FQDNFromDB -ComputerName $ComputerName -SQLServer $SQLServer -Database $OrchStagingDB

    #region create credential objects
    Write-CMLogEntry "Creating necessary credential objects"
    $RemotingCreds = Get-StoredCredential -ComputerName $ComputerName -SQLServer $SQLServer -Database $OrchStagingDB
    #endregion create credential objects

    #region verify that the server is powered on after we send the startup command
    Write-CMLogEntry "Checking for VM with name $ComputerName"
    $VM = Get-VM -Name $ComputerName -ErrorAction Stop
    if (($VM | Measure-Object | Select-Object -ExpandProperty Count) -gt 1) {
        Write-CMLogEntry "Identified more than one VM with name $ComputerName. Selecting VM based on CustomField containing SRM"
        $VM = $VM | Where-Object { $_.CustomFields.Keys -match 'srm' }
    }
    Write-CMLogEntry "Identified [VM=$($VM.Name)] based off [ComputerName=$ComputerName]"

    $Sleep = Get-Random -Minimum 1 -Maximum 30
    Write-CMLogEntry "Sleeping for a random interval of $Sleep seconds"
    Start-Sleep -Seconds $Sleep

    #region tell the servers to startup
    Write-CMLogEntry "Executing Start-VM -VM $ComputerName"
    Update-DBServerStatus -LastStatus 'Starting Up'
    Start-VM -VM $VM -Confirm:$false -ErrorAction Stop
    Write-CMLogEntry "VM powered on successfully"
    #endregion tell the servers to startup

    Write-CMLogEntry "Waiting for $ComputerName to be PoweredOn"
    New-LoopAction -LoopTimeout 30 -LoopTimeoutType Minutes -LoopDelay 10 -ExitCondition { $VM.PowerState -eq "PoweredOn" } -IfSucceedScript {
        Write-CMLogEntry "Verified that [Server=$script:ComputerName] was PoweredOn"
        Update-DBServerStatus -LastStatus 'Verified PoweredOn'
    } -IfTimeoutScript {
        Write-CMLogEntry "Failed to verify that the [Server=$script:ComputerName] was PoweredOn after 30 minutes" -Severity 3
        throw "ERROR: Failed to verify that the [Server=$script:ComputerName] was PoweredOn after 30 minutes"
    } -ScriptBlock {
        $VM = Get-VM -Name $script:ComputerName
    }
    #endregion verify that the server is powered on

    #region initiate CIMSession, looping until one is made, or it has been 10 minutes
    Update-DBServerStatus -LastStatus 'Creating CIMSession'
    Write-CMLogEntry 'Creating CIMSession'    
    New-LoopAction -LoopTimeout 10 -LoopTimeoutType Minutes -LoopDelay 10 -ExitCondition { $script:CIMSession } -ScriptBlock {
        $script:CIMSession = New-MrCimSession -Credential $script:RemotingCreds -ComputerName $script:FQDN
    } -IfSucceedScript { 
        Update-DBServerStatus -LastStatus "CIMSession Created"
        Write-CMLogEntry 'CIMSession created succesfully' 
    } -IfTimeoutScript {
        Write-CMLogEntry 'Failed to create CIMSession'
        throw 'Failed to create CIMsession'
    }
    #endregion initiate CIMSession, looping until one is made, or it has been 10 minutes

    #region post-reboot service check loop
    # loop to validate critical services start. This is how we know when the server has 'started' - check every 5 seconds for 15 minutes
    $MonitoredServices = @('netlogon', 'winmgmt', 'ccmexec')
    Update-DBServerStatus -LastStatus "Waiting on $($MonitoredServices -join ' ') services"
    Write-CMLogEntry "Waiting on $($MonitoredServices -join ' ') services"
    [hashtable]$Services = @{ }
    foreach ($StartupService in $MonitoredServices) {
        $Services.Add($StartupService, 'Stopped')
    }

    $newLoopActionSplat = @{
        LoopTimeoutType = 'Minutes'
        ScriptBlock     = {
            foreach ($Service in @($script:Services.Keys)) {
                if ($script:Services[$Service] -ne 'Running') {
                    if (Get-CimInstance -CimSession $script:CIMSession -ClassName Win32_Service -Filter "Name='$Service' and State='Running'") {
                        $script:Services.Remove($Service)
                        Write-CMLogEntry "Validated that $($Service) is in a state of 'Running'"
                        if ($script:Services.Count -ne 0) {
                            Update-DBServerStatus -LastStatus "Waiting on $($script:Services.Keys -join ' ') services"
                            Write-CMLogEntry "Waiting on $($script:Services.Keys -join ' ') services"
                        }
                    }
                }
            }
        }
        ExitCondition   = { $script:Services.Count -eq 0 }
        IfTimeoutScript = { throw 'Service startup failed' }
        LoopDelayType   = 'Seconds'
        LoopDelay       = 10
        IfSucceedScript = {
            Write-CMLogEntry "Validated that $($MonitoredServices -join ',') services are running"
            $script:ResultStatus = 'Success'
        }
        LoopTimeout     = 15
    }
    New-LoopAction @newLoopActionSplat
    #endregion post-reboot service check loop
}
catch {
    # Catch any errors thrown above here, setting the result status and recording the error message to return to the activity for data bus publishing
    $ResultStatus = "Failed"
    $ErrorMessage = $error[0].Exception.Message
    $LastStatus = "Failed: $global:CurrentAction"
    Update-DBServerStatus -LastStatus $LastStatus
    Write-CMLogEntry "Exception caught during action [$global:CurrentAction]: $ErrorMessage" -Severity 3
}
finally {
    # Always do whatever is in the finally block. In this case, adding some additional detail about the outcome to the trace log for return
    if ($ErrorMessage.Length -gt 0) {
        Write-CMLogEntry "Exiting script with result [$ResultStatus] and error message [$ErrorMessage]" -Severity 3
    }
    else {
        Write-CMLogEntry "Exiting script with result [$ResultStatus]"
    }

}
# Record end of activity script process
Update-DBServerStatus -Status "Finished $ScriptName"
Update-DBServerStatus -Stage 'End' -Component $ScriptName
Write-CMLogEntry "Script finished"