function Test-PatchesNeeded {
    param
    (
        [parameter(Mandatory = $true)]
        [string]$Grouping,
        # Provides the grouping of servers we are checking for available patches on

        [parameter(Mandatory = $true)]
        [string]$DryRun,
        # skips patching check so that we can perform a dry run of the drain an resume

        [parameter(Mandatory = $true)]
        [int32]$RBInstance,
        # RBInstance which represents the Runbook Process ID for this runbook workflow

        [parameter(Mandatory = $true)]
        [string]$SQLServer,
        # Database server for staging information during the patching process

        [parameter(Mandatory = $true)]
        [string]$OrchStagingDB,
        # Database for staging information during the patching process

        [parameter(Mandatory = $true)]
        [string]$LogLocation
        # UNC path to store log files in
    )

    #region import modules
    Import-Module -Name ComplexPatching
    #endregion import modules

    #-----------------------------------------------------------------------

    ## Initialize result and trace variables
    # $ResultStatus provides basic success/failed indicator
    # $ErrorMessage captures any error text generated by script
    # $Trace is used to record a running log of actions
    [bool]$DryRun = ConvertTo-Boolean $DryRun
    $ResultStatus = ""
    $ErrorMessage = ""
    $global:CurrentAction = ""
    $ScriptName = $((Split-Path $PSCommandPath -Leaf) -Replace '.ps1', $null)

    #region set our defaults for the our functions
    #region Write-CMLogEntry defaults
    $Bias = Get-WmiObject -Class Win32_TimeZone | Select-Object -ExpandProperty Bias
    $PSDefaultParameterValues.Add("Write-CMLogEntry:Bias", $Bias)
    $PSDefaultParameterValues.Add("Write-CMLogEntry:FileName", [string]::Format("{0}-{1}.log", $RBInstance, $Grouping))
    $PSDefaultParameterValues.Add("Write-CMLogEntry:Folder", $LogLocation)
    $PSDefaultParameterValues.Add("Write-CMLogEntry:Component", "[$Grouping]::[$ScriptName]")
    #endregion Write-CMLogEntry defaults

    #region Get-PendingSCMReboot defaults
    $PSDefaultParameterValues.Add("Get-PendingSCCMReboot:Credential", $RemotingCreds)
    #endregion Get-PendingSCMReboot defaults

    #region Start-CompPatchQuery defaults
    $PSDefaultParameterValues.Add("Start-CompPatchQuery:SQLServer", $SQLServer)
    $PSDefaultParameterValues.Add("Start-CompPatchQuery:Database", $OrchStagingDB)
    #endregion Start-CompPatchQuery defaults
    #endregion set our defaults for our functions

    Write-CMLogEntry "Runbook activity script started - [Running On = $env:ComputerName]"

    try {

        $ServerStatus = [System.Collections.ArrayList]::new()
        $Query = [string]::Format("Select * from [dbo].[ServerStatus] where Grouping = '{0}'", $Grouping)
        $GroupingInfo = Start-CompPatchQuery -Query $Query
        $TierCount = $GroupingInfo | Select-Object -ExpandProperty Tier | Measure-Object -Maximum | Select-Object -ExpandProperty Maximum
        $ServersInGroup = $GroupingInfo | Select-Object -ExpandProperty ServerName -Unique
        $PatchThisGroup = $GroupingInfo | Select-Object -ExpandProperty Patch
        if ($PatchThisGroup -contains $true -or $DryRun) {
            if (-not $DryRun) {
                foreach ($Server in $ServersInGroup) {
                    #region create credential objects
                    $RemotingCreds = Get-StoredCredential -ComputerName $Server -SQLServer $SQLServer -Database $OrchStagingDB
                    #endregion create credential objects

                    $FQDN = Get-FQDNFromDB -ComputerName $Server -SQLServer $SQLServer -Database $OrchStagingDB

                    $Patches = $false
                    $StartTime = [System.TimeZoneInfo]::ConvertTimeBySystemTimeZoneId((Get-Date), 'Eastern Standard Time')
                    Write-CMLogEntry "Started - [Server=$Server] [RBInstance=$RBInstance] [StartTime=$StartTime]"

                    #region Check for updates and note if any available
                    [System.Management.ManagementObject[]]$MissingUpdates = Get-WmiObject -Class CCM_SoftwareUpdate -Filter "(ComplianceState=0) and (NOT Name LIKE '%Definition%')" -Namespace root\CCM\ClientSDK -ComputerName $FQDN -Credential $RemotingCreds
                    if ($MissingUpdates -is [Object]) {
                        $Patches = $true
                    }
                    #endregion Check for updates and note if any available

                    #region check for pending reboot from SCCM
                    $ServerPendingReboot = Get-PendingSCCMReboot -ComputerName $FQDN
                    Write-CMLogEntry "[ServerName=$Server] [PendingReboot=$ServerPendingReboot] [PatchesAvailable=$Patches]"
                    #endregion check for pending reboot from SCCM

                    $ServerStatus.Add([PSCustomObject] @{
                            ServerName       = $Server;
                            PatchesAvailable = $Patches;
                            PendingReboot    = $ServerPendingReboot;
                        }) | Out-Null
                }
                $PatchesAvailable = $false
                if ($ServerStatus.PatchesAvailable -contains $true) {
                    $PatchesAvailable = $true

                    #region mark StartTime for grouping in DB
                    [string]$Now = [System.TimeZoneInfo]::ConvertTimeBySystemTimeZoneId((Get-Date), 'Eastern Standard Time')
                    $Query = [string]::Format("INSERT INTO [dbo].[PatchingDuration] (Grouping, TierCount, StartTime, RBInstance, DryRun) VALUES ('{0}', {1}, '{2}', '{3}', '{4}')", $Grouping, $TierCount, $Now, $RBInstance, $DryRun)
                    Start-CompPatchQuery -Query $Query
                    #endregion mark StartTime for grouping in DB
                }
                $PendingReboot = $false
                if ($ServerStatus.PendingReboot -contains $true) {
                    $PendingReboot = $true
                }
            }
            else {
                Write-CMLogEntry "Script was invoked with the DryRun parameter - will continue on regardless of patch availability"
                #region mark StartTime for grouping in DB
                [string]$Now = [System.TimeZoneInfo]::ConvertTimeBySystemTimeZoneId((Get-Date), 'Eastern Standard Time')
                $Query = [string]::Format("INSERT INTO [dbo].[PatchingDuration] (Grouping, TierCount, StartTime, RBInstance, DryRun) VALUES ('{0}', {1}, '{2}', '{3}', '{4}')", $Grouping, $TierCount, $Now, $RBInstance, $DryRun)
                Start-CompPatchQuery -Query $Query
                #endregion mark StartTime for grouping in DB
            
                $PatchesAvailable = $true
            }
        }
        else {
            Write-CMLogEntry "All servers in [Grouping=$Grouping] are marked [Patch=$false] so patching for this grouping will be skipped"
            $PatchesAvailable = $false
            $PendingReboot = $false
        }
    }
    catch {
        # Catch any errors thrown above here, setting the result status and recording the error message to return to the activity for data bus publishing
        $ResultStatus = "Failed"
        $ErrorMessage = $error[0].Exception.Message
        Write-CMLogEntry "Exception caught during action [$global:CurrentAction]: $ErrorMessage" -Severity 3
    }
    finally {
        # Always do whatever is in the finally block. In this case, adding some additional detail about the outcome to the trace log for return
        if ($ErrorMessage.Length -gt 0) {
            Write-CMLogEntry "Exiting script with result [$ResultStatus] and error message [$ErrorMessage]" -Severity 3
        }
        else {
            Write-CMLogEntry "Exiting script with [PatchesAvailable=$PatchesAvailable] [PendingReboot=$PendingReboot]"
        }

    }

    # Record end of activity script process
    Write-CMLogEntry "Script finished"
}